// @TODO generated by studio
// not refactored
import type { API, FileInfo, Options } from "jscodeshift";

function capitalize(word: string): string {
  if (word.length === 0) return word;
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function transform(
  file: FileInfo,
  api: API,
  options: Options,
): string | undefined {
  const j = api.jscodeshift;
  const root = j(file.source);
  let dirtyFlag = false;

  // Find the nested Route component with auth function
  root
    .find(j.JSXElement, {
      openingElement: { name: { name: "Route" } },
    })
    .forEach((path) => {
      const renderAttr = path.value.openingElement.attributes.find(
        (attr) =>
          j.JSXAttribute.check(attr) &&
          j.JSXIdentifier.check(attr.name) &&
          attr.name.name === "render",
      );

      if (renderAttr) {
        j(renderAttr)
          .find(j.JSXElement)
          .forEach((el) => {
            el.value.openingElement.attributes?.forEach((attr) => {
              if (
                j.JSXAttribute.check(attr) &&
                j.JSXIdentifier.check(attr.name) &&
                attr.name.name === "component"
              ) {
                if (
                  j.JSXExpressionContainer.check(attr.value) &&
                  j.CallExpression.check(attr.value.expression)
                ) {
                  const callExpr = attr.value.expression;
                  if (j.Identifier.check(callExpr.callee)) {
                    const componentArg = callExpr.arguments[0];
                    if (j.Identifier.check(componentArg)) {
                      const componentName = componentArg.name;
                      const newComponentName = `${capitalize(callExpr.callee.name)}${componentName}`;

                      const existingConst = root
                        .find(j.VariableDeclaration)
                        .filter((path) =>
                          path.value.declarations.some(
                            (decl) =>
                              j.Identifier.check(decl.id) &&
                              decl.id.name === newComponentName,
                          ),
                        );

                      if (existingConst.size() === 0) {
                        // Insert the new constant declaration at the top of the file
                        const newConst = j.variableDeclaration("const", [
                          j.variableDeclarator(
                            j.identifier(newComponentName),
                            j.callExpression(
                              j.identifier(callExpr.callee.name),
                              [j.identifier(componentName)],
                            ),
                          ),
                        ]);
                        root.get().node.program.body.unshift(newConst);
                      }

                      // Replace the component prop with the new constant
                      attr.value = j.jsxExpressionContainer(
                        j.identifier(newComponentName),
                      );
                      dirtyFlag = true;
                    }
                  }
                }
              }
            });
          });
      }
    });

  if (!dirtyFlag) {
    return undefined;
  }
  return root.toSource(options);
}

export default transform;
