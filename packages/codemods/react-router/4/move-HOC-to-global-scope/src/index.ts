// @TODO generated by studio
// not refactored
import type { API, FileInfo, Options } from "jscodeshift";

function capitalize(word: string): string {
  if (word.length === 0) return word;
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function transform(
  file: FileInfo,
  api: API,
  options: Options,
): string | undefined {
  const j = api.jscodeshift;
  const root = j(file.source);
  let dirtyFlag = false;

  // Find the nested Route component with auth function
  root
    .find(j.JSXElement, {
      openingElement: { name: { name: "Route" } },
    })
    .forEach((path) => {
      const renderAttr = path.value.openingElement.attributes.find(
        (attr) =>
          j.JSXAttribute.check(attr) &&
          j.JSXIdentifier.check(attr.name) &&
          attr.name.name === "render",
      );

      if (
        renderAttr &&
        j.JSXExpressionContainer.check(renderAttr.value) &&
        j.ArrowFunctionExpression.check(renderAttr.value.expression)
      ) {
        const renderBody = renderAttr.value.expression.body;

        if (j.JSXElement.check(renderBody)) {
          renderBody.openingElement.attributes.forEach((attr) => {
            if (
              j.JSXAttribute.check(attr) &&
              j.JSXIdentifier.check(attr.name) &&
              attr.name.name === "component"
            ) {
              if (
                j.JSXExpressionContainer.check(attr.value) &&
                j.CallExpression.check(attr.value.expression)
              ) {
                const callExpr = attr.value.expression;
                if (j.Identifier.check(callExpr.callee)) {
                  const componentArg = callExpr.arguments[0];
                  if (j.Identifier.check(componentArg)) {
                    const componentName = componentArg.name;
                    const newComponentName = `${capitalize(callExpr.callee.name)}${componentName}`;

                    const existingConst = root
                      .find(j.VariableDeclaration)
                      .filter((path) =>
                        path.value.declarations.some(
                          (decl) =>
                            j.Identifier.check(decl.id) &&
                            decl.id.name === newComponentName,
                        ),
                      );

                    if (existingConst.size() === 0) {
                      // Insert the new constant declaration at the top of the file
                      const newConst = j.variableDeclaration("const", [
                        j.variableDeclarator(
                          j.identifier(newComponentName),
                          j.callExpression(j.identifier(callExpr.callee.name), [
                            j.identifier(componentName),
                          ]),
                        ),
                      ]);
                      root.get().node.program.body.unshift(newConst);
                    }

                    // Replace the component prop with the new constant
                    attr.value = j.jsxExpressionContainer(
                      j.identifier(newComponentName),
                    );
                    dirtyFlag = true;
                  }
                }
              }
            }
          });
        }
      }
    });

  if (!dirtyFlag) {
    return undefined;
  }
  return root.toSource(options);
}

export default transform;
