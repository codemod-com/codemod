---
title: 'Creating Codemod Workflows'
sidebarTitle: 'Creating & Running Workflows'
icon: 'code'
---

Codemod Workflows are self-hostable automations designed for running large-scale code transformation jobs.

## Core Features

- **Single binary, no server** — works anywhere you have a shell  
- **Schema-validated shared state** — tasks share one JSON document  
- **Dynamic matrix fan-out** — tasks appear/disappear as state arrays change  
- **Manual gates** — pause tasks until you trigger them  
- **Durable & resumable** — state survives crashes or reboots  
- **Parallel scheduling** — independent nodes run when dependencies allow  
- **Host-shell execution** — commands run directly on your machine (container runtimes on the roadmap)

---

## Quick Start

<Steps>
  <Step title="Create a new codemod project">
    ```bash
    npx codemod@next init
    ```
    When creating a new codemod project, you'll be prompted for:
    - **Project directory**
    - **Codemod type:**
      - Shell command workflow codemod
      - JavaScript ast-grep codemod
      - YAML ast-grep codemod
    - **Project name**
    - **Description**
    - **Author**
    - **License type**
    - **If your codemod is private**

    This will create a new folder with all the necessary files and structure for your chosen codemod type.
  </Step>
  <Step title="Explore the generated project">
    ```
    example-codemod/
    ├── .gitignore
    ├── README.md           # Project usage and development instructions
    ├── codemod.yaml        # Codemod metadata and registry info
    ├── workflow.yaml       # Workflow definition for running the codemod
    ├── rules/
    │   └── config.yml      # Example ast-grep rules
    ├── scripts/            # (empty) for custom scripts
    └── tests/
        ├── input/          # (empty) for test fixtures
        └── expected/       # (empty) for test fixtures
    ```
  </Step>
  <Step title="Understand the example workflow">
    The generated `workflow.yaml` defines a simple workflow that applies an AST-grep rule to all TypeScript files in the `src/` directory (excluding test files):

    ```yaml
    id: example-codemod
    version: "1"
    nodes:
      - id: apply-rules
        name: Apply AST-grep Rules
        steps:
          - name: "Scan TypeScript files only"
            ast-grep:
              include:
                - "**/*.ts"
                - "**/*.tsx"
              exclude:
                - "**/*.test.ts"
                - "**/*.spec.ts"
              base_path: "src"
              config_file: "rules/config.yml"
    ```

    The referenced `rules/config.yml` contains an example rule:

    ```yaml
    id: replace-console-log
    language: tsx
    rule:
      any:
        - pattern: console.log($ARG)
    fix:
      logger.log($ARG)
    ```

    This rule will replace all `console.log(...)` calls with `logger.log(...)` in your TypeScript/TSX files.
  </Step>
  <Step title="Validate & run your workflow">
    ```bash
    npx codemod@next workflow validate -w workflow.yaml
    npx codemod@next workflow run -w workflow.yaml
    ```
    This will check your workflow for errors and then run it locally.
  </Step>
</Steps>


---

## Directory Layout

```
my-workflow/
├─ workflow.yaml
├─ scripts/
└─ rules/
```

The folder—called a **workflow bundle**—is the root when you run `npx codemod@next workflow run ./my-workflow/`. `$CODEMOD_PATH` points here inside every task.

<Accordion title="Workflow Bundle & Loading Workflows">
A <b>workflow bundle</b> is a directory containing your <code>workflow.yaml</code> and any scripts, rules, or assets referenced by your workflow.

- When you run <code>npx codemod@next workflow run ./my-workflow/</code>, the directory is used as the root for all relative paths.
- You can also run a workflow directly from a file:
  <br/>
  <code>npx codemod@next workflow run -w workflow.yaml</code>

<Info>
Registry support (run workflows from remote sources) is planned for the future.
</Info>
</Accordion>

## Workflow File

```yaml workflow.yaml
version: "1"
state:
  schema: []
templates: []
nodes: []
```

A workflow has four top-level keys:

| Key | Required | Purpose |
|-----|----------|---------|
| `version`   | ✓ | Declare workflow schema version (default: `"1"`). |
| [`state`](#shared-state)     |   | Declares shared-state schema. |
| [`templates`](#templates) |   | Re-usable blocks. |
| [`nodes`](#nodes)     | ✓ | Executable DAG. |

---

## Shared State

```yaml
state:
  schema:
    - name: shards
      type: array
      items:
        type: object
        properties:
          team:    { type: string }
          shardId: { type: string }
```

---

## Templates

```yaml
templates:
  - id: checkout-repo
    name: Checkout Repository
    inputs:
      - name: repo_url
        type: string
        required: true
    steps:
      - name: Clone
        run: git clone ${{inputs.repo_url}} repo
```

**Template Inputs & Usage**:

Templates can define required or optional inputs, which are referenced in their steps.

To use a template in a node step:

```yaml
steps:
  - name: Checkout
    uses:
      - template: checkout-repo
        inputs:
          repo_url: ${{params.repo_url}}
```

---

## Nodes & Steps

### Nodes

```yaml
nodes:
  - id: build
    name: Build
    type: automatic
    steps:
      - name: npm install
        run: npm ci
```

<ParamField path="id" type="string" required>
  Unique within the workflow.
</ParamField>
<ParamField path="name" type="string" required>
  Display name.
</ParamField>
<ParamField path="type" type="string" required>
  `automatic` (default) or `manual`.
</ParamField>
<ParamField path="depends_on" type="string[]">
  Upstream node IDs.
</ParamField>
<ParamField path="trigger" type="object">
  `{ type: manual }` → approval gate.
</ParamField>
<ParamField path="strategy" type="object">
  Matrix configuration.
</ParamField>
<ParamField path="steps" type="array" required>
  Ordered list of steps.
</ParamField>
<ParamField path="runtime" type="object">Container/runtime configuration (e.g., Docker).</ParamField>
<ParamField path="env" type="object">Environment variables for the node or step.</ParamField>

### Step

<ParamField path="name" type="string" required>
  Step label.
</ParamField>
<ParamField path="run" type="string">
  Inline shell command to execute.
  <br/>
  <b>Provide either <code>run</code> or <code>uses</code>, not both.</b>
</ParamField>
<ParamField path="uses" type="object">
  Template call(s).
  <br/>
  <b>Provide either <code>run</code> or <code>uses</code>, not both.</b>
</ParamField>


## Matrix Strategy

```yaml
nodes:
  - id: matrix-codemod
    name: Matrix Codemod
    strategy:
      type: matrix
      from_state: shards
    steps:
      - name: Codemod
        run: node codemod.js --team=$team --shard=$shardId
```

<Accordion title="Dynamic Matrix Task Recompilation">
When the array referenced by `from_state` changes, Codemod CLI:

1. Creates new tasks for new items.
2. Marks tasks as `WontDo` if their item is removed.
3. Leaves existing tasks untouched if their item remains.

<Info>
Matrix nodes have a <b>master task</b> that tracks the status of all generated tasks.
</Info>
</Accordion>

---

## Manual Trigger

```yaml
nodes:
  - id: manual-approval
    name: Manual Approval
    trigger:
      type: manual
    steps:
      - name: Wait for approval
        run: echo "Waiting for manual approval"
```

<Accordion title="Task UUIDs & Resume">
Manual tasks are assigned unique UUIDs. You can resume:

- All paused tasks:
  ```bash
  npx codemod@next workflow resume -i <run-id> --trigger-all
  ```
- A specific task:
  ```bash
  npx codemod@next workflow resume -i <run-id> -t <task-uuid>
  ```
</Accordion>

---

## State Updates

| Syntax         | Meaning                                      | Example                                      |
|----------------|----------------------------------------------|----------------------------------------------|
| `KEY=VAL`      | Set state key to value                       | `count=10`                                   |
| `KEY@=VAL`     | Append value to array at state key           | `shards@={"team":"core","shardId":"1"}`      |
| Dot notation   | Set nested state fields                      | `config.retries=5`                           |
| JSON values    | Use valid JSON for objects/arrays            | `user={"name":"Alice","id":123}`             |

<Info>
All state updates must be valid JSON if not a primitive. Updates are applied only if the task exits successfully.
</Info>

<AccordionGroup>
<Accordion title="Container Runtimes">
You can specify how a node or template runs:

```yaml
runtime:
  type: docker
  image: node:18-alpine
```

Supported types: `docker`, `podman`, `direct` (host shell).
</Accordion>

<Accordion title="State Management & Persistence">
<Info>
Workflow state is persisted after every task. If interrupted, you can resume from the last saved state—no work is lost.
</Info>
</Accordion>

<Accordion title="Matrix Master Task">
For matrix nodes, a master task aggregates the status of all generated tasks.  
If all child tasks complete, the master is `Completed`. If any fail, the master is `Failed`.
</Accordion>

<Accordion title="Cyclic Dependency Example">
If your workflow has a cycle:

```yaml
nodes:
  - id: a
    depends_on: [b]
  - id: b
    depends_on: [a]
```

You'll see:

```bash
✗ Workflow definition is invalid
Error: Cyclic dependency detected: a → b → a
```
<Info>
This error is shown when you run `npx codemod@next workflow validate` or `npx codemod@next workflow run` on a workflow with a cyclic dependency.
</Info>
</Accordion>
</AccordionGroup>

---

## End-to-End Example

```yaml
version: "1"
state:
  schema:
    - name: shards
      type: array
      items:
        type: object
        properties:
          team: { type: string }
          shardId: { type: string }
templates:
  - id: checkout-repo
    name: Checkout Repository
    inputs:
      - name: repo_url
        type: string
        required: true
    steps:
      - name: Clone
        run: git clone ${{inputs.repo_url}} repo
nodes:
  - id: make-shards
    name: Make Shards
    type: automatic
    steps:
      - name: Write shards
        run: echo 'shards@={"team":"core","shardId":"1"}' >> "$STATE_OUTPUTS"
  - id: matrix-codemod
    name: Matrix Codemod
    strategy:
      type: matrix
      from_state: shards
    trigger:
      type: manual
    steps:
      - name: Codemod
        run: node codemod.js --team=$team --shard=$shardId
      - name: PR
        run: codemodctl pr create
```

---

## Task Statuses

<ResponseField name="Pending">
  Queued; waiting for runner.
</ResponseField>
<ResponseField name="Running">
  Currently executing.
</ResponseField>
<ResponseField name="Completed">
  Succeeded; diff applied.
</ResponseField>
<ResponseField name="Failed">
  Script exited non-zero; diff discarded.
</ResponseField>
<ResponseField name="AwaitingTrigger">
  Waiting for manual approval.
</ResponseField>
<ResponseField name="Blocked">
  Dependencies not finished.
</ResponseField>
<ResponseField name="WontDo">
  Matrix item removed; task skipped.
</ResponseField>


## Variable Resolution

- **Parameter:** `${{params.branch}}` — Supplied at runtime
- **Environment:** `${{env.CI}}` — Host env var
- **Shared State:** `${{state.counter}}` — Live JSON value

<Info>
In matrix tasks, each object key becomes an environment variable (e.g., `$team`, `$shardId`, …).
</Info>

---

## CLI Reference

Codemod CLI (new) is accessible using the `npx codemod@next` command. The following commands and options are available:

- `workflow` — Manage workflows (see subcommands below)
- `jssg` — JavaScript ast-grep execution (see subcommands below)
- `init` — Initialize a new workflow project
- `login` — Login to a registry
- `logout` — Logout from a registry
- `whoami` — Show current authentication status
- `publish` — Publish a workflow
- `search` — Search for packages in the registry
- `run` — Run a codemod from the registry
- `cache` — Manage package cache (see subcommands below)

---

### `codemod@next workflow`

Manage and execute workflow YAMLs.

<ResponseField name="workflow run">
  Run a workflow.
</ResponseField>
```bash
npx codemod@next workflow run -w <workflow.yaml|directory> [--param key=value]
```
- `-w, --workflow <PATH>` (string) — Path to workflow file or directory. (required)
- `--param <KEY=VALUE>` (string) — Workflow parameters (format: key=value).

<ResponseField name="workflow resume">
  Resume a paused workflow.
</ResponseField>
```bash
npx codemod@next workflow resume -i <ID> [-t <TASK>] [--trigger-all]
```
- `-i, --id <ID>` (string) — Workflow run ID. (required)
- `-t, --task <TASK>` (string) — Task ID to trigger (can be specified multiple times).
- `--trigger-all` (boolean) — Trigger all awaiting tasks.

<ResponseField name="workflow validate">
  Validate a workflow file.
</ResponseField>
```bash
npx codemod@next workflow validate -w <workflow.yaml>
```
- `-w, --workflow <FILE>` (string) — Path to workflow file. (required)

| Check                       | Ensures                                 |
|-----------------------------|-----------------------------------------|
| Schema validation           | YAML matches the workflow spec           |
| Unique IDs                  | Node & template IDs are unique           |
| Dependency validation       | Every `depends_on` exists                |
| Cyclic dependency detection | DAG has no cycles                        |
| Template references         | All `template:` IDs exist                |
| Matrix validation           | `from_state` matches schema              |
| State schema validation     | `state.schema` is valid                  |
| Variable syntax             | `${{…}}` uses `params`, `env`, `state`   |

<Info>
  <b>Why validate?</b> Validation catches issues before execution, saving time and preventing runtime errors.
</Info>

<ResponseField name="workflow status">
  Show workflow run status.
</ResponseField>
```bash
npx codemod@next workflow status -i <ID>
```
- `-i, --id <ID>` (string) — Workflow run ID. (required)

<ResponseField name="workflow list">
  List workflow runs.
</ResponseField>
```bash
npx codemod@next workflow list [-l <LIMIT>]
```
- `-l, --limit <LIMIT>` (number) — Number of workflow runs to show. (default: 10)

<ResponseField name="workflow cancel">
  Cancel a workflow run.
</ResponseField>
```bash
npx codemod@next workflow cancel -i <ID>
```
- `-i, --id <ID>` (string) — Workflow run ID. (required)

---

### `codemod@next jssg`

See [this page](/cli/jssg) for full details and options for running and testing jssg codemods.

---

### `codemod@next init`

Initialize a new workflow project.
```bash
npx codemod@next init [PATH] [options]
```
<ResponseField name="[PATH]" type="string">
  Project directory name.
</ResponseField>
<ResponseField name="--name <NAME>" type="string">
  Project name (defaults to directory name).
</ResponseField>
<ResponseField name="--project-type <PROJECT_TYPE>" type="string">
  Project type: `shell`, `ast-grep-js`, `ast-grep-yaml`.
</ResponseField>
<ResponseField name="--language <LANGUAGE>" type="string">
  Target language.
</ResponseField>
<ResponseField name="--description <DESCRIPTION>" type="string">
  Project description.
</ResponseField>
<ResponseField name="--author <AUTHOR>" type="string">
  Author name and email.
</ResponseField>
<ResponseField name="--license <LICENSE>" type="string">
  License.
</ResponseField>
<ResponseField name="--private" type="boolean">
  Make package private.
</ResponseField>
<ResponseField name="--force" type="boolean">
  Overwrite existing files.
</ResponseField>
<ResponseField name="--no-interactive" type="boolean">
  Use defaults without prompts.
</ResponseField>


### `codemod@next login`

Login to a registry.
```bash
npx codemod@next login [--registry <REGISTRY>] [--scope <SCOPE>]
```
<ResponseField name="--registry <REGISTRY>" type="string">
  Registry URL.
</ResponseField>
<ResponseField name="--scope <SCOPE>" type="string">
  Organization or user scope for publishing.
</ResponseField>


### `codemod@next logout`

Logout from a registry.
```bash
npx codemod@next logout [--registry <REGISTRY>] [--all]
```
<ResponseField name="--registry <REGISTRY>" type="string">
  Registry URL to logout from.
</ResponseField>
<ResponseField name="--all" type="boolean">
  Logout from all registries.
</ResponseField>


### `codemod@next whoami`

Show current authentication status.
```bash
npx codemod@next whoami [--registry <REGISTRY>] [--detailed]
```
<ResponseField name="--registry <REGISTRY>" type="string">
  Registry URL to check.
</ResponseField>
<ResponseField name="--detailed" type="boolean">
  Show detailed information including token scopes.
</ResponseField>

### `codemod@next publish`

Publish a workflow to a registry.
```bash
npx codemod@next publish [PATH] [options]
```
<ResponseField name="[PATH]" type="string">
  Path to codemod directory.
</ResponseField>
<ResponseField name="--version <VERSION>" type="string">
  Explicit version override.
</ResponseField>
<ResponseField name="--registry <REGISTRY>" type="string">
  Target registry URL.
</ResponseField>
<ResponseField name="--tag <TAG>" type="string">
  Tag for the release.
</ResponseField>
<ResponseField name="--access <ACCESS>" type="string">
  Access level (`public`, `private`).
</ResponseField>
<ResponseField name="--dry-run" type="boolean">
  Validate and pack without uploading.
</ResponseField>


### `codemod@next search`

Search for packages in the registry.
```bash
npx codemod@next search [QUERY] [options]
```

---

## Roadmap

<Update description="Container runtime support">
  Support for <code>runtime: docker</code> and other container runtimes, allowing tasks to run in isolated environments.
</Update>
<Update description="Parameter flags">
  Ability to pass parameters to workflows via <code>--param key=value</code> flags.
</Update>
<Update description="Nested matrix strategies">
  Support for matrix strategies within matrix strategies, enabling more complex task fan-out.
</Update>