// Generated by dts-bundle v0.7.3

declare module 'ast-types' {
    import { ASTNode, Type, AnyType, Field } from "ast-types/lib/types";
    import { NodePath } from "ast-types/lib/node-path";
    import { namedTypes } from "ast-types/gen/namedTypes";
    import { builders } from "ast-types/gen/builders";
    import { Visitor } from "ast-types/gen/visitor";
    const astNodesAreEquivalent: {
        (a: any, b: any, problemPath?: any): boolean;
        assert(a: any, b: any): void;
    }, builders: builders, builtInTypes: {
        string: Type<string>;
        function: Type<Function>;
        array: Type<any[]>;
        object: Type<{
            [key: string]: any;
        }>;
        RegExp: Type<RegExp>;
        Date: Type<Date>;
        number: Type<number>;
        boolean: Type<boolean>;
        null: Type<null>;
        undefined: Type<undefined>;
    }, defineMethod: (name: any, func?: Function | undefined) => Function, eachField: (object: any, callback: (name: any, value: any) => any, context?: any) => void, finalize: () => void, getBuilderName: (typeName: any) => any, getFieldNames: (object: any) => string[], getFieldValue: (object: any, fieldName: any) => any, getSupertypeNames: (typeName: string) => string[], NodePath: import("./lib/node-path").NodePathConstructor, Path: import("./lib/path").PathConstructor, PathVisitor: import("./lib/path-visitor").PathVisitorConstructor, someField: (object: any, callback: (name: any, value: any) => any, context?: any) => boolean, Type: {
        or(...types: any[]): Type<any>;
        from<T>(value: any, name?: string | undefined): Type<T>;
        def(typeName: string): import("./lib/types").Def<any>;
        hasDef(typeName: string): boolean;
    }, use: <T>(plugin: import("./types").Plugin<T>) => T, visit: <M = {}>(node: ASTNode, methods?: Visitor<M> | undefined) => any;
    export { AnyType, ASTNode, astNodesAreEquivalent, builders, builtInTypes, defineMethod, eachField, Field, finalize, getBuilderName, getFieldNames, getFieldValue, getSupertypeNames, namedTypes, NodePath, Path, PathVisitor, someField, Type, use, visit, Visitor, };
}

declare module 'ast-types/lib/types' {
    import { Fork } from "ast-types/types";
    type Deep = boolean | ((type: Type<any>, value: any) => void);
    export type Type<T> = ArrayType<T> | IdentityType<T> | ObjectType<T> | OrType<T> | PredicateType<T>;
    export interface AnyType {
        toString(): string;
        check(value: any, deep?: Deep): boolean;
        assert(value: any, deep?: Deep): boolean;
        arrayOf(): AnyType;
    }
    abstract class BaseType<T> {
        abstract toString(): string;
        abstract check(value: any, deep?: Deep): value is T;
        assert(value: any, deep?: Deep): value is T;
        arrayOf(): Type<T[]>;
    }
    class ArrayType<T> extends BaseType<T> {
        readonly elemType: Type<T extends (infer E)[] ? E : never>;
        readonly kind: "ArrayType";
        constructor(elemType: Type<T extends (infer E)[] ? E : never>);
        toString(): string;
        check(value: any, deep?: Deep): value is T;
    }
    class IdentityType<T> extends BaseType<T> {
        readonly value: T;
        readonly kind: "IdentityType";
        constructor(value: T);
        toString(): string;
        check(value: any, deep?: Deep): value is T;
    }
    class ObjectType<T> extends BaseType<T> {
        readonly fields: Field<any>[];
        readonly kind: "ObjectType";
        constructor(fields: Field<any>[]);
        toString(): string;
        check(value: any, deep?: Deep): value is T;
    }
    class OrType<T> extends BaseType<T> {
        readonly types: Type<any>[];
        readonly kind: "OrType";
        constructor(types: Type<any>[]);
        toString(): string;
        check(value: any, deep?: Deep): value is T;
    }
    class PredicateType<T> extends BaseType<T> {
        readonly name: string;
        readonly predicate: (value: any, deep?: Deep) => boolean;
        readonly kind: "PredicateType";
        constructor(name: string, predicate: (value: any, deep?: Deep) => boolean);
        toString(): string;
        check(value: any, deep?: Deep): value is T;
    }
    export abstract class Def<T = any> {
        readonly type: Type<T>;
        readonly typeName: string;
        baseNames: string[];
        ownFields: {
            [name: string]: Field<any>;
        };
        allSupertypes: {
            [name: string]: Def<any>;
        };
        supertypeList: string[];
        allFields: {
            [name: string]: Field<any>;
        };
        fieldNames: string[];
        finalized: boolean;
        buildable: boolean;
        buildParams: string[];
        constructor(type: Type<T>, typeName: string);
        isSupertypeOf(that: Def<any>): boolean;
        checkAllFields(value: any, deep?: any): boolean;
        abstract check(value: any, deep?: any): boolean;
        bases(...supertypeNames: string[]): this;
        abstract build(...buildParams: string[]): this;
        abstract field(name: string, type: any, defaultFn?: Function, hidden?: boolean): this;
        abstract finalize(): void;
    }
    class Field<T> {
        readonly name: string;
        readonly type: Type<T>;
        readonly defaultFn?: Function | undefined;
        readonly hidden: boolean;
        constructor(name: string, type: Type<T>, defaultFn?: Function | undefined, hidden?: boolean);
        toString(): string;
        getValue(obj: {
            [key: string]: any;
        }): any;
    }
    type FieldType<T> = Field<T>;
    export { FieldType as Field };
    export interface ASTNode {
        type: string;
    }
    export interface Builder {
        (...args: any[]): ASTNode;
        from(obj: {
            [param: string]: any;
        }): ASTNode;
    }
    export default function typesPlugin(_fork: Fork): {
        Type: {
            or(...types: any[]): Type<any>;
            from<T>(value: any, name?: string | undefined): Type<T>;
            def(typeName: string): Def;
            hasDef(typeName: string): boolean;
        };
        builtInTypes: {
            string: Type<string>;
            function: Type<Function>;
            array: Type<any[]>;
            object: Type<{
                [key: string]: any;
            }>;
            RegExp: Type<RegExp>;
            Date: Type<Date>;
            number: Type<number>;
            boolean: Type<boolean>;
            null: Type<null>;
            undefined: Type<undefined>;
        };
        getSupertypeNames: (typeName: string) => string[];
        computeSupertypeLookupTable: (candidates: any) => {
            [typeName: string]: any;
        };
        builders: import("../gen/builders").builders;
        defineMethod: (name: any, func?: Function | undefined) => Function;
        getBuilderName: (typeName: any) => any;
        getStatementBuilderName: (typeName: any) => any;
        namedTypes: import("../gen/namedTypes").NamedTypes;
        getFieldNames: (object: any) => string[];
        getFieldValue: (object: any, fieldName: any) => any;
        eachField: (object: any, callback: (name: any, value: any) => any, context?: any) => void;
        someField: (object: any, callback: (name: any, value: any) => any, context?: any) => boolean;
        finalize: () => void;
    };
}

declare module 'ast-types/lib/node-path' {
    import { Fork } from "ast-types/types";
    import { ASTNode } from "ast-types/lib/types";
    import { Path } from "ast-types/lib/path";
    import { Scope } from "ast-types/lib/scope";
    export interface NodePath<N = any, V = any> extends Path<V> {
        node: N;
        parent: any;
        scope: any;
        replace: Path['replace'];
        prune(...args: any[]): any;
        _computeNode(): any;
        _computeParent(): any;
        _computeScope(): Scope | null;
        getValueProperty(name: any): any;
        needsParens(assumeExpressionContext?: boolean): boolean;
        canBeFirstInStatement(): boolean;
        firstInStatement(): boolean;
    }
    export interface NodePathConstructor {
        new <N extends ASTNode = any, V = any>(value: any, parentPath?: any, name?: any): NodePath<N, V>;
    }
    export default function nodePathPlugin(fork: Fork): NodePathConstructor;
}

declare module 'ast-types/gen/namedTypes' {
    import { Omit } from "ast-types/types";
    import { Type } from "ast-types/lib/types";
    import * as K from "ast-types/gen/kinds";
    export namespace namedTypes {
        interface Printable {
            loc?: K.SourceLocationKind | null;
        }
        interface SourceLocation {
            start: K.PositionKind;
            end: K.PositionKind;
            source?: string | null;
        }
        interface Node extends Printable {
            type: string;
            comments?: K.CommentKind[] | null;
        }
        interface Comment extends Printable {
            value: string;
            leading?: boolean;
            trailing?: boolean;
        }
        interface Position {
            line: number;
            column: number;
        }
        interface File extends Omit<Node, "type"> {
            type: "File";
            program: K.ProgramKind;
            name?: string | null;
        }
        interface Program extends Omit<Node, "type"> {
            type: "Program";
            body: K.StatementKind[];
            directives?: K.DirectiveKind[];
            interpreter?: K.InterpreterDirectiveKind | null;
        }
        interface Statement extends Node {
        }
        interface Function extends Node {
            id?: K.IdentifierKind | null;
            params: K.PatternKind[];
            body: K.BlockStatementKind;
            generator?: boolean;
            async?: boolean;
            expression?: boolean;
            defaults?: (K.ExpressionKind | null)[];
            rest?: K.IdentifierKind | null;
            returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
            predicate?: K.FlowPredicateKind | null;
        }
        interface Expression extends Node {
        }
        interface Pattern extends Node {
        }
        interface Identifier extends Omit<Expression, "type">, Omit<Pattern, "type"> {
            type: "Identifier";
            name: string;
            optional?: boolean;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        }
        interface BlockStatement extends Omit<Statement, "type"> {
            type: "BlockStatement";
            body: K.StatementKind[];
            directives?: K.DirectiveKind[];
        }
        interface EmptyStatement extends Omit<Statement, "type"> {
            type: "EmptyStatement";
        }
        interface ExpressionStatement extends Omit<Statement, "type"> {
            type: "ExpressionStatement";
            expression: K.ExpressionKind;
        }
        interface IfStatement extends Omit<Statement, "type"> {
            type: "IfStatement";
            test: K.ExpressionKind;
            consequent: K.StatementKind;
            alternate?: K.StatementKind | null;
        }
        interface LabeledStatement extends Omit<Statement, "type"> {
            type: "LabeledStatement";
            label: K.IdentifierKind;
            body: K.StatementKind;
        }
        interface BreakStatement extends Omit<Statement, "type"> {
            type: "BreakStatement";
            label?: K.IdentifierKind | null;
        }
        interface ContinueStatement extends Omit<Statement, "type"> {
            type: "ContinueStatement";
            label?: K.IdentifierKind | null;
        }
        interface WithStatement extends Omit<Statement, "type"> {
            type: "WithStatement";
            object: K.ExpressionKind;
            body: K.StatementKind;
        }
        interface SwitchStatement extends Omit<Statement, "type"> {
            type: "SwitchStatement";
            discriminant: K.ExpressionKind;
            cases: K.SwitchCaseKind[];
            lexical?: boolean;
        }
        interface SwitchCase extends Omit<Node, "type"> {
            type: "SwitchCase";
            test: K.ExpressionKind | null;
            consequent: K.StatementKind[];
        }
        interface ReturnStatement extends Omit<Statement, "type"> {
            type: "ReturnStatement";
            argument: K.ExpressionKind | null;
        }
        interface ThrowStatement extends Omit<Statement, "type"> {
            type: "ThrowStatement";
            argument: K.ExpressionKind;
        }
        interface TryStatement extends Omit<Statement, "type"> {
            type: "TryStatement";
            block: K.BlockStatementKind;
            handler?: K.CatchClauseKind | null;
            handlers?: K.CatchClauseKind[];
            guardedHandlers?: K.CatchClauseKind[];
            finalizer?: K.BlockStatementKind | null;
        }
        interface CatchClause extends Omit<Node, "type"> {
            type: "CatchClause";
            param?: K.PatternKind | null;
            guard?: K.ExpressionKind | null;
            body: K.BlockStatementKind;
        }
        interface WhileStatement extends Omit<Statement, "type"> {
            type: "WhileStatement";
            test: K.ExpressionKind;
            body: K.StatementKind;
        }
        interface DoWhileStatement extends Omit<Statement, "type"> {
            type: "DoWhileStatement";
            body: K.StatementKind;
            test: K.ExpressionKind;
        }
        interface ForStatement extends Omit<Statement, "type"> {
            type: "ForStatement";
            init: K.VariableDeclarationKind | K.ExpressionKind | null;
            test: K.ExpressionKind | null;
            update: K.ExpressionKind | null;
            body: K.StatementKind;
        }
        interface Declaration extends Statement {
        }
        interface VariableDeclaration extends Omit<Declaration, "type"> {
            type: "VariableDeclaration";
            kind: "var" | "let" | "const";
            declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[];
        }
        interface ForInStatement extends Omit<Statement, "type"> {
            type: "ForInStatement";
            left: K.VariableDeclarationKind | K.ExpressionKind;
            right: K.ExpressionKind;
            body: K.StatementKind;
        }
        interface DebuggerStatement extends Omit<Statement, "type"> {
            type: "DebuggerStatement";
        }
        interface FunctionDeclaration extends Omit<Function, "type" | "id">, Omit<Declaration, "type"> {
            type: "FunctionDeclaration";
            id: K.IdentifierKind | null;
        }
        interface FunctionExpression extends Omit<Function, "type">, Omit<Expression, "type"> {
            type: "FunctionExpression";
        }
        interface VariableDeclarator extends Omit<Node, "type"> {
            type: "VariableDeclarator";
            id: K.PatternKind;
            init?: K.ExpressionKind | null;
        }
        interface ThisExpression extends Omit<Expression, "type"> {
            type: "ThisExpression";
        }
        interface ArrayExpression extends Omit<Expression, "type"> {
            type: "ArrayExpression";
            elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[];
        }
        interface ObjectExpression extends Omit<Expression, "type"> {
            type: "ObjectExpression";
            properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[];
        }
        interface Property extends Omit<Node, "type"> {
            type: "Property";
            kind: "init" | "get" | "set";
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            value: K.ExpressionKind | K.PatternKind;
            method?: boolean;
            shorthand?: boolean;
            computed?: boolean;
            decorators?: K.DecoratorKind[] | null;
        }
        interface Literal extends Omit<Expression, "type"> {
            type: "Literal";
            value: string | boolean | null | number | RegExp;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
        }
        interface SequenceExpression extends Omit<Expression, "type"> {
            type: "SequenceExpression";
            expressions: K.ExpressionKind[];
        }
        interface UnaryExpression extends Omit<Expression, "type"> {
            type: "UnaryExpression";
            operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
            argument: K.ExpressionKind;
            prefix?: boolean;
        }
        interface BinaryExpression extends Omit<Expression, "type"> {
            type: "BinaryExpression";
            operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "in" | "instanceof" | "**";
            left: K.ExpressionKind;
            right: K.ExpressionKind;
        }
        interface AssignmentExpression extends Omit<Expression, "type"> {
            type: "AssignmentExpression";
            operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=";
            left: K.PatternKind | K.MemberExpressionKind;
            right: K.ExpressionKind;
        }
        interface ChainElement extends Node {
            optional?: boolean;
        }
        interface MemberExpression extends Omit<Expression, "type">, Omit<ChainElement, "type"> {
            type: "MemberExpression";
            object: K.ExpressionKind;
            property: K.IdentifierKind | K.ExpressionKind;
            computed?: boolean;
        }
        interface UpdateExpression extends Omit<Expression, "type"> {
            type: "UpdateExpression";
            operator: "++" | "--";
            argument: K.ExpressionKind;
            prefix: boolean;
        }
        interface LogicalExpression extends Omit<Expression, "type"> {
            type: "LogicalExpression";
            operator: "||" | "&&" | "??";
            left: K.ExpressionKind;
            right: K.ExpressionKind;
        }
        interface ConditionalExpression extends Omit<Expression, "type"> {
            type: "ConditionalExpression";
            test: K.ExpressionKind;
            consequent: K.ExpressionKind;
            alternate: K.ExpressionKind;
        }
        interface NewExpression extends Omit<Expression, "type"> {
            type: "NewExpression";
            callee: K.ExpressionKind;
            arguments: (K.ExpressionKind | K.SpreadElementKind)[];
            typeArguments?: null | K.TypeParameterInstantiationKind;
        }
        interface CallExpression extends Omit<Expression, "type">, Omit<ChainElement, "type"> {
            type: "CallExpression";
            callee: K.ExpressionKind;
            arguments: (K.ExpressionKind | K.SpreadElementKind)[];
            typeArguments?: null | K.TypeParameterInstantiationKind;
        }
        interface RestElement extends Omit<Pattern, "type"> {
            type: "RestElement";
            argument: K.PatternKind;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        }
        interface TypeAnnotation extends Omit<Node, "type"> {
            type: "TypeAnnotation";
            typeAnnotation: K.FlowTypeKind;
        }
        interface TSTypeAnnotation extends Omit<Node, "type"> {
            type: "TSTypeAnnotation";
            typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind;
        }
        interface SpreadElementPattern extends Omit<Pattern, "type"> {
            type: "SpreadElementPattern";
            argument: K.PatternKind;
        }
        interface ArrowFunctionExpression extends Omit<Function, "type" | "id" | "body" | "generator">, Omit<Expression, "type"> {
            type: "ArrowFunctionExpression";
            id?: null;
            body: K.BlockStatementKind | K.ExpressionKind;
            generator?: false;
        }
        interface ForOfStatement extends Omit<Statement, "type"> {
            type: "ForOfStatement";
            left: K.VariableDeclarationKind | K.PatternKind;
            right: K.ExpressionKind;
            body: K.StatementKind;
            await?: boolean;
        }
        interface YieldExpression extends Omit<Expression, "type"> {
            type: "YieldExpression";
            argument: K.ExpressionKind | null;
            delegate?: boolean;
        }
        interface GeneratorExpression extends Omit<Expression, "type"> {
            type: "GeneratorExpression";
            body: K.ExpressionKind;
            blocks: K.ComprehensionBlockKind[];
            filter: K.ExpressionKind | null;
        }
        interface ComprehensionBlock extends Omit<Node, "type"> {
            type: "ComprehensionBlock";
            left: K.PatternKind;
            right: K.ExpressionKind;
            each: boolean;
        }
        interface ComprehensionExpression extends Omit<Expression, "type"> {
            type: "ComprehensionExpression";
            body: K.ExpressionKind;
            blocks: K.ComprehensionBlockKind[];
            filter: K.ExpressionKind | null;
        }
        interface ObjectProperty extends Omit<Node, "type"> {
            shorthand?: boolean;
            type: "ObjectProperty";
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            value: K.ExpressionKind | K.PatternKind;
            accessibility?: K.LiteralKind | null;
            computed?: boolean;
        }
        interface PropertyPattern extends Omit<Pattern, "type"> {
            type: "PropertyPattern";
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            pattern: K.PatternKind;
            computed?: boolean;
        }
        interface ObjectPattern extends Omit<Pattern, "type"> {
            type: "ObjectPattern";
            properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind)[];
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            decorators?: K.DecoratorKind[] | null;
        }
        interface ArrayPattern extends Omit<Pattern, "type"> {
            type: "ArrayPattern";
            elements: (K.PatternKind | K.SpreadElementKind | null)[];
        }
        interface SpreadElement extends Omit<Node, "type"> {
            type: "SpreadElement";
            argument: K.ExpressionKind;
        }
        interface AssignmentPattern extends Omit<Pattern, "type"> {
            type: "AssignmentPattern";
            left: K.PatternKind;
            right: K.ExpressionKind;
        }
        interface MethodDefinition extends Omit<Declaration, "type"> {
            type: "MethodDefinition";
            kind: "constructor" | "method" | "get" | "set";
            key: K.ExpressionKind;
            value: K.FunctionKind;
            computed?: boolean;
            static?: boolean;
            decorators?: K.DecoratorKind[] | null;
        }
        interface ClassPropertyDefinition extends Omit<Declaration, "type"> {
            type: "ClassPropertyDefinition";
            definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind;
        }
        interface ClassProperty extends Omit<Declaration, "type"> {
            type: "ClassProperty";
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            computed?: boolean;
            value: K.ExpressionKind | null;
            static?: boolean;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            variance?: K.VarianceKind | "plus" | "minus" | null;
            access?: "public" | "private" | "protected" | undefined;
        }
        interface ClassBody extends Omit<Declaration, "type"> {
            type: "ClassBody";
            body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassPrivatePropertyKind | K.ClassMethodKind | K.ClassPrivateMethodKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
        }
        interface ClassDeclaration extends Omit<Declaration, "type"> {
            type: "ClassDeclaration";
            id: K.IdentifierKind | null;
            body: K.ClassBodyKind;
            superClass?: K.ExpressionKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
            superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
            implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
        }
        interface ClassExpression extends Omit<Expression, "type"> {
            type: "ClassExpression";
            id?: K.IdentifierKind | null;
            body: K.ClassBodyKind;
            superClass?: K.ExpressionKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
            superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
            implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
        }
        interface Super extends Omit<Expression, "type"> {
            type: "Super";
        }
        interface Specifier extends Node {
        }
        interface ModuleSpecifier extends Specifier {
            local?: K.IdentifierKind | null;
            id?: K.IdentifierKind | null;
            name?: K.IdentifierKind | null;
        }
        interface ImportSpecifier extends Omit<ModuleSpecifier, "type"> {
            type: "ImportSpecifier";
            imported: K.IdentifierKind;
        }
        interface ImportDefaultSpecifier extends Omit<ModuleSpecifier, "type"> {
            type: "ImportDefaultSpecifier";
        }
        interface ImportNamespaceSpecifier extends Omit<ModuleSpecifier, "type"> {
            type: "ImportNamespaceSpecifier";
        }
        interface ImportDeclaration extends Omit<Declaration, "type"> {
            type: "ImportDeclaration";
            specifiers?: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[];
            source: K.LiteralKind;
            importKind?: "value" | "type" | "typeof";
        }
        interface ExportNamedDeclaration extends Omit<Declaration, "type"> {
            type: "ExportNamedDeclaration";
            declaration: K.DeclarationKind | null;
            specifiers?: K.ExportSpecifierKind[];
            source?: K.LiteralKind | null;
        }
        interface ExportSpecifier extends Omit<ModuleSpecifier, "type"> {
            type: "ExportSpecifier";
            exported: K.IdentifierKind;
        }
        interface ExportDefaultDeclaration extends Omit<Declaration, "type"> {
            type: "ExportDefaultDeclaration";
            declaration: K.DeclarationKind | K.ExpressionKind;
        }
        interface ExportAllDeclaration extends Omit<Declaration, "type"> {
            type: "ExportAllDeclaration";
            source: K.LiteralKind;
            exported: K.IdentifierKind | null;
        }
        interface TaggedTemplateExpression extends Omit<Expression, "type"> {
            type: "TaggedTemplateExpression";
            tag: K.ExpressionKind;
            quasi: K.TemplateLiteralKind;
        }
        interface TemplateLiteral extends Omit<Expression, "type"> {
            type: "TemplateLiteral";
            quasis: K.TemplateElementKind[];
            expressions: K.ExpressionKind[];
        }
        interface TemplateElement extends Omit<Node, "type"> {
            type: "TemplateElement";
            value: {
                cooked: string | null;
                raw: string;
            };
            tail: boolean;
        }
        interface MetaProperty extends Omit<Expression, "type"> {
            type: "MetaProperty";
            meta: K.IdentifierKind;
            property: K.IdentifierKind;
        }
        interface AwaitExpression extends Omit<Expression, "type"> {
            type: "AwaitExpression";
            argument: K.ExpressionKind | null;
            all?: boolean;
        }
        interface SpreadProperty extends Omit<Node, "type"> {
            type: "SpreadProperty";
            argument: K.ExpressionKind;
        }
        interface SpreadPropertyPattern extends Omit<Pattern, "type"> {
            type: "SpreadPropertyPattern";
            argument: K.PatternKind;
        }
        interface ImportExpression extends Omit<Expression, "type"> {
            type: "ImportExpression";
            source: K.ExpressionKind;
        }
        interface ChainExpression extends Omit<Expression, "type"> {
            type: "ChainExpression";
            expression: K.ChainElementKind;
        }
        interface OptionalCallExpression extends Omit<CallExpression, "type" | "optional"> {
            type: "OptionalCallExpression";
            optional?: boolean;
        }
        interface OptionalMemberExpression extends Omit<MemberExpression, "type" | "optional"> {
            type: "OptionalMemberExpression";
            optional?: boolean;
        }
        interface JSXAttribute extends Omit<Node, "type"> {
            type: "JSXAttribute";
            name: K.JSXIdentifierKind | K.JSXNamespacedNameKind;
            value?: K.LiteralKind | K.JSXExpressionContainerKind | K.JSXElementKind | K.JSXFragmentKind | null;
        }
        interface JSXIdentifier extends Omit<Identifier, "type" | "name"> {
            type: "JSXIdentifier";
            name: string;
        }
        interface JSXNamespacedName extends Omit<Node, "type"> {
            type: "JSXNamespacedName";
            namespace: K.JSXIdentifierKind;
            name: K.JSXIdentifierKind;
        }
        interface JSXExpressionContainer extends Omit<Expression, "type"> {
            type: "JSXExpressionContainer";
            expression: K.ExpressionKind | K.JSXEmptyExpressionKind;
        }
        interface JSXElement extends Omit<Expression, "type"> {
            type: "JSXElement";
            openingElement: K.JSXOpeningElementKind;
            closingElement?: K.JSXClosingElementKind | null;
            children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
            name?: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
            selfClosing?: boolean;
            attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
        }
        interface JSXFragment extends Omit<Expression, "type"> {
            type: "JSXFragment";
            openingFragment: K.JSXOpeningFragmentKind;
            closingFragment: K.JSXClosingFragmentKind;
            children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
        }
        interface JSXMemberExpression extends Omit<MemberExpression, "type" | "object" | "property" | "computed"> {
            type: "JSXMemberExpression";
            object: K.JSXIdentifierKind | K.JSXMemberExpressionKind;
            property: K.JSXIdentifierKind;
            computed?: boolean;
        }
        interface JSXSpreadAttribute extends Omit<Node, "type"> {
            type: "JSXSpreadAttribute";
            argument: K.ExpressionKind;
        }
        interface JSXEmptyExpression extends Omit<Node, "type"> {
            type: "JSXEmptyExpression";
        }
        interface JSXText extends Omit<Literal, "type" | "value"> {
            type: "JSXText";
            value: string;
            raw?: string;
        }
        interface JSXSpreadChild extends Omit<Node, "type"> {
            type: "JSXSpreadChild";
            expression: K.ExpressionKind;
        }
        interface JSXOpeningElement extends Omit<Node, "type"> {
            type: "JSXOpeningElement";
            name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
            attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
            selfClosing?: boolean;
        }
        interface JSXClosingElement extends Omit<Node, "type"> {
            type: "JSXClosingElement";
            name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
        }
        interface JSXOpeningFragment extends Omit<Node, "type"> {
            type: "JSXOpeningFragment";
        }
        interface JSXClosingFragment extends Omit<Node, "type"> {
            type: "JSXClosingFragment";
        }
        interface Decorator extends Omit<Node, "type"> {
            type: "Decorator";
            expression: K.ExpressionKind;
        }
        interface PrivateName extends Omit<Expression, "type">, Omit<Pattern, "type"> {
            type: "PrivateName";
            id: K.IdentifierKind;
        }
        interface ClassPrivateProperty extends Omit<ClassProperty, "type" | "key" | "value"> {
            type: "ClassPrivateProperty";
            key: K.PrivateNameKind;
            value?: K.ExpressionKind | null;
        }
        interface TypeParameterDeclaration extends Omit<Node, "type"> {
            type: "TypeParameterDeclaration";
            params: K.TypeParameterKind[];
        }
        interface TSTypeParameterDeclaration extends Omit<Declaration, "type"> {
            type: "TSTypeParameterDeclaration";
            params: K.TSTypeParameterKind[];
        }
        interface TypeParameterInstantiation extends Omit<Node, "type"> {
            type: "TypeParameterInstantiation";
            params: K.FlowTypeKind[];
        }
        interface TSTypeParameterInstantiation extends Omit<Node, "type"> {
            type: "TSTypeParameterInstantiation";
            params: K.TSTypeKind[];
        }
        interface ClassImplements extends Omit<Node, "type"> {
            type: "ClassImplements";
            id: K.IdentifierKind;
            superClass?: K.ExpressionKind | null;
            typeParameters?: K.TypeParameterInstantiationKind | null;
        }
        interface TSType extends Node {
        }
        interface TSHasOptionalTypeParameterInstantiation {
            typeParameters?: K.TSTypeParameterInstantiationKind | null;
        }
        interface TSExpressionWithTypeArguments extends Omit<TSType, "type">, TSHasOptionalTypeParameterInstantiation {
            type: "TSExpressionWithTypeArguments";
            expression: K.IdentifierKind | K.TSQualifiedNameKind;
        }
        interface Flow extends Node {
        }
        interface FlowType extends Flow {
        }
        interface AnyTypeAnnotation extends Omit<FlowType, "type"> {
            type: "AnyTypeAnnotation";
        }
        interface EmptyTypeAnnotation extends Omit<FlowType, "type"> {
            type: "EmptyTypeAnnotation";
        }
        interface MixedTypeAnnotation extends Omit<FlowType, "type"> {
            type: "MixedTypeAnnotation";
        }
        interface VoidTypeAnnotation extends Omit<FlowType, "type"> {
            type: "VoidTypeAnnotation";
        }
        interface SymbolTypeAnnotation extends Omit<FlowType, "type"> {
            type: "SymbolTypeAnnotation";
        }
        interface NumberTypeAnnotation extends Omit<FlowType, "type"> {
            type: "NumberTypeAnnotation";
        }
        interface BigIntTypeAnnotation extends Omit<FlowType, "type"> {
            type: "BigIntTypeAnnotation";
        }
        interface NumberLiteralTypeAnnotation extends Omit<FlowType, "type"> {
            type: "NumberLiteralTypeAnnotation";
            value: number;
            raw: string;
        }
        interface NumericLiteralTypeAnnotation extends Omit<FlowType, "type"> {
            type: "NumericLiteralTypeAnnotation";
            value: number;
            raw: string;
        }
        interface BigIntLiteralTypeAnnotation extends Omit<FlowType, "type"> {
            type: "BigIntLiteralTypeAnnotation";
            value: null;
            raw: string;
        }
        interface StringTypeAnnotation extends Omit<FlowType, "type"> {
            type: "StringTypeAnnotation";
        }
        interface StringLiteralTypeAnnotation extends Omit<FlowType, "type"> {
            type: "StringLiteralTypeAnnotation";
            value: string;
            raw: string;
        }
        interface BooleanTypeAnnotation extends Omit<FlowType, "type"> {
            type: "BooleanTypeAnnotation";
        }
        interface BooleanLiteralTypeAnnotation extends Omit<FlowType, "type"> {
            type: "BooleanLiteralTypeAnnotation";
            value: boolean;
            raw: string;
        }
        interface NullableTypeAnnotation extends Omit<FlowType, "type"> {
            type: "NullableTypeAnnotation";
            typeAnnotation: K.FlowTypeKind;
        }
        interface NullLiteralTypeAnnotation extends Omit<FlowType, "type"> {
            type: "NullLiteralTypeAnnotation";
        }
        interface NullTypeAnnotation extends Omit<FlowType, "type"> {
            type: "NullTypeAnnotation";
        }
        interface ThisTypeAnnotation extends Omit<FlowType, "type"> {
            type: "ThisTypeAnnotation";
        }
        interface ExistsTypeAnnotation extends Omit<FlowType, "type"> {
            type: "ExistsTypeAnnotation";
        }
        interface ExistentialTypeParam extends Omit<FlowType, "type"> {
            type: "ExistentialTypeParam";
        }
        interface FunctionTypeAnnotation extends Omit<FlowType, "type"> {
            type: "FunctionTypeAnnotation";
            params: K.FunctionTypeParamKind[];
            returnType: K.FlowTypeKind;
            rest: K.FunctionTypeParamKind | null;
            typeParameters: K.TypeParameterDeclarationKind | null;
        }
        interface FunctionTypeParam extends Omit<Node, "type"> {
            type: "FunctionTypeParam";
            name: K.IdentifierKind | null;
            typeAnnotation: K.FlowTypeKind;
            optional: boolean;
        }
        interface ArrayTypeAnnotation extends Omit<FlowType, "type"> {
            type: "ArrayTypeAnnotation";
            elementType: K.FlowTypeKind;
        }
        interface ObjectTypeAnnotation extends Omit<FlowType, "type"> {
            type: "ObjectTypeAnnotation";
            properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[];
            indexers?: K.ObjectTypeIndexerKind[];
            callProperties?: K.ObjectTypeCallPropertyKind[];
            inexact?: boolean | undefined;
            exact?: boolean;
            internalSlots?: K.ObjectTypeInternalSlotKind[];
        }
        interface ObjectTypeProperty extends Omit<Node, "type"> {
            type: "ObjectTypeProperty";
            key: K.LiteralKind | K.IdentifierKind;
            value: K.FlowTypeKind;
            optional: boolean;
            variance?: K.VarianceKind | "plus" | "minus" | null;
        }
        interface ObjectTypeSpreadProperty extends Omit<Node, "type"> {
            type: "ObjectTypeSpreadProperty";
            argument: K.FlowTypeKind;
        }
        interface ObjectTypeIndexer extends Omit<Node, "type"> {
            type: "ObjectTypeIndexer";
            id: K.IdentifierKind;
            key: K.FlowTypeKind;
            value: K.FlowTypeKind;
            variance?: K.VarianceKind | "plus" | "minus" | null;
            static?: boolean;
        }
        interface ObjectTypeCallProperty extends Omit<Node, "type"> {
            type: "ObjectTypeCallProperty";
            value: K.FunctionTypeAnnotationKind;
            static?: boolean;
        }
        interface ObjectTypeInternalSlot extends Omit<Node, "type"> {
            type: "ObjectTypeInternalSlot";
            id: K.IdentifierKind;
            value: K.FlowTypeKind;
            optional: boolean;
            static: boolean;
            method: boolean;
        }
        interface Variance extends Omit<Node, "type"> {
            type: "Variance";
            kind: "plus" | "minus";
        }
        interface QualifiedTypeIdentifier extends Omit<Node, "type"> {
            type: "QualifiedTypeIdentifier";
            qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
            id: K.IdentifierKind;
        }
        interface GenericTypeAnnotation extends Omit<FlowType, "type"> {
            type: "GenericTypeAnnotation";
            id: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
            typeParameters: K.TypeParameterInstantiationKind | null;
        }
        interface MemberTypeAnnotation extends Omit<FlowType, "type"> {
            type: "MemberTypeAnnotation";
            object: K.IdentifierKind;
            property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind;
        }
        interface UnionTypeAnnotation extends Omit<FlowType, "type"> {
            type: "UnionTypeAnnotation";
            types: K.FlowTypeKind[];
        }
        interface IntersectionTypeAnnotation extends Omit<FlowType, "type"> {
            type: "IntersectionTypeAnnotation";
            types: K.FlowTypeKind[];
        }
        interface TypeofTypeAnnotation extends Omit<FlowType, "type"> {
            type: "TypeofTypeAnnotation";
            argument: K.FlowTypeKind;
        }
        interface TypeParameter extends Omit<FlowType, "type"> {
            type: "TypeParameter";
            name: string;
            variance?: K.VarianceKind | "plus" | "minus" | null;
            bound?: K.TypeAnnotationKind | null;
            default?: K.FlowTypeKind | null;
        }
        interface InterfaceTypeAnnotation extends Omit<FlowType, "type"> {
            type: "InterfaceTypeAnnotation";
            body: K.ObjectTypeAnnotationKind;
            extends?: K.InterfaceExtendsKind[] | null;
        }
        interface InterfaceExtends extends Omit<Node, "type"> {
            type: "InterfaceExtends";
            id: K.IdentifierKind;
            typeParameters?: K.TypeParameterInstantiationKind | null;
        }
        interface InterfaceDeclaration extends Omit<Declaration, "type"> {
            type: "InterfaceDeclaration";
            id: K.IdentifierKind;
            typeParameters?: K.TypeParameterDeclarationKind | null;
            body: K.ObjectTypeAnnotationKind;
            extends: K.InterfaceExtendsKind[];
        }
        interface DeclareInterface extends Omit<InterfaceDeclaration, "type"> {
            type: "DeclareInterface";
        }
        interface TypeAlias extends Omit<Declaration, "type"> {
            type: "TypeAlias";
            id: K.IdentifierKind;
            typeParameters: K.TypeParameterDeclarationKind | null;
            right: K.FlowTypeKind;
        }
        interface DeclareTypeAlias extends Omit<TypeAlias, "type"> {
            type: "DeclareTypeAlias";
        }
        interface OpaqueType extends Omit<Declaration, "type"> {
            type: "OpaqueType";
            id: K.IdentifierKind;
            typeParameters: K.TypeParameterDeclarationKind | null;
            impltype: K.FlowTypeKind;
            supertype: K.FlowTypeKind | null;
        }
        interface DeclareOpaqueType extends Omit<OpaqueType, "type" | "impltype"> {
            type: "DeclareOpaqueType";
            impltype: K.FlowTypeKind | null;
        }
        interface TypeCastExpression extends Omit<Expression, "type"> {
            type: "TypeCastExpression";
            expression: K.ExpressionKind;
            typeAnnotation: K.TypeAnnotationKind;
        }
        interface TupleTypeAnnotation extends Omit<FlowType, "type"> {
            type: "TupleTypeAnnotation";
            types: K.FlowTypeKind[];
        }
        interface DeclareVariable extends Omit<Statement, "type"> {
            type: "DeclareVariable";
            id: K.IdentifierKind;
        }
        interface DeclareFunction extends Omit<Statement, "type"> {
            type: "DeclareFunction";
            id: K.IdentifierKind;
            predicate?: K.FlowPredicateKind | null;
        }
        interface FlowPredicate extends Flow {
        }
        interface DeclareClass extends Omit<InterfaceDeclaration, "type"> {
            type: "DeclareClass";
        }
        interface DeclareModule extends Omit<Statement, "type"> {
            type: "DeclareModule";
            id: K.IdentifierKind | K.LiteralKind;
            body: K.BlockStatementKind;
        }
        interface DeclareModuleExports extends Omit<Statement, "type"> {
            type: "DeclareModuleExports";
            typeAnnotation: K.TypeAnnotationKind;
        }
        interface DeclareExportDeclaration extends Omit<Declaration, "type"> {
            type: "DeclareExportDeclaration";
            default: boolean;
            declaration: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | K.TypeAliasKind | K.DeclareOpaqueTypeKind | K.InterfaceDeclarationKind | null;
            specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
            source?: K.LiteralKind | null;
        }
        interface ExportBatchSpecifier extends Omit<Specifier, "type"> {
            type: "ExportBatchSpecifier";
        }
        interface DeclareExportAllDeclaration extends Omit<Declaration, "type"> {
            type: "DeclareExportAllDeclaration";
            source?: K.LiteralKind | null;
        }
        interface InferredPredicate extends Omit<FlowPredicate, "type"> {
            type: "InferredPredicate";
        }
        interface DeclaredPredicate extends Omit<FlowPredicate, "type"> {
            type: "DeclaredPredicate";
            value: K.ExpressionKind;
        }
        interface EnumDeclaration extends Omit<Declaration, "type"> {
            type: "EnumDeclaration";
            id: K.IdentifierKind;
            body: K.EnumBooleanBodyKind | K.EnumNumberBodyKind | K.EnumStringBodyKind | K.EnumSymbolBodyKind;
        }
        interface EnumBooleanBody {
            type: "EnumBooleanBody";
            members: K.EnumBooleanMemberKind[];
            explicitType: boolean;
        }
        interface EnumNumberBody {
            type: "EnumNumberBody";
            members: K.EnumNumberMemberKind[];
            explicitType: boolean;
        }
        interface EnumStringBody {
            type: "EnumStringBody";
            members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[];
            explicitType: boolean;
        }
        interface EnumSymbolBody {
            type: "EnumSymbolBody";
            members: K.EnumDefaultedMemberKind[];
        }
        interface EnumBooleanMember {
            type: "EnumBooleanMember";
            id: K.IdentifierKind;
            init: K.LiteralKind | boolean;
        }
        interface EnumNumberMember {
            type: "EnumNumberMember";
            id: K.IdentifierKind;
            init: K.LiteralKind;
        }
        interface EnumStringMember {
            type: "EnumStringMember";
            id: K.IdentifierKind;
            init: K.LiteralKind;
        }
        interface EnumDefaultedMember {
            type: "EnumDefaultedMember";
            id: K.IdentifierKind;
        }
        interface ExportDeclaration extends Omit<Declaration, "type"> {
            type: "ExportDeclaration";
            default: boolean;
            declaration: K.DeclarationKind | K.ExpressionKind | null;
            specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
            source?: K.LiteralKind | null;
        }
        interface Block extends Comment {
            type: "Block";
        }
        interface Line extends Comment {
            type: "Line";
        }
        interface Noop extends Omit<Statement, "type"> {
            type: "Noop";
        }
        interface DoExpression extends Omit<Expression, "type"> {
            type: "DoExpression";
            body: K.StatementKind[];
        }
        interface BindExpression extends Omit<Expression, "type"> {
            type: "BindExpression";
            object: K.ExpressionKind | null;
            callee: K.ExpressionKind;
        }
        interface ParenthesizedExpression extends Omit<Expression, "type"> {
            type: "ParenthesizedExpression";
            expression: K.ExpressionKind;
        }
        interface ExportNamespaceSpecifier extends Omit<Specifier, "type"> {
            type: "ExportNamespaceSpecifier";
            exported: K.IdentifierKind;
        }
        interface ExportDefaultSpecifier extends Omit<Specifier, "type"> {
            type: "ExportDefaultSpecifier";
            exported: K.IdentifierKind;
        }
        interface CommentBlock extends Comment {
            type: "CommentBlock";
        }
        interface CommentLine extends Comment {
            type: "CommentLine";
        }
        interface Directive extends Omit<Node, "type"> {
            type: "Directive";
            value: K.DirectiveLiteralKind;
        }
        interface DirectiveLiteral extends Omit<Node, "type">, Omit<Expression, "type"> {
            type: "DirectiveLiteral";
            value?: string;
        }
        interface InterpreterDirective extends Omit<Node, "type"> {
            type: "InterpreterDirective";
            value: string;
        }
        interface StringLiteral extends Omit<Literal, "type" | "value"> {
            type: "StringLiteral";
            value: string;
        }
        interface NumericLiteral extends Omit<Literal, "type" | "value"> {
            type: "NumericLiteral";
            value: number;
            raw?: string | null;
            extra?: {
                rawValue: number;
                raw: string;
            };
        }
        interface BigIntLiteral extends Omit<Literal, "type" | "value"> {
            type: "BigIntLiteral";
            value: string | number;
            extra?: {
                rawValue: string;
                raw: string;
            };
        }
        interface NullLiteral extends Omit<Literal, "type" | "value"> {
            type: "NullLiteral";
            value?: null;
        }
        interface BooleanLiteral extends Omit<Literal, "type" | "value"> {
            type: "BooleanLiteral";
            value: boolean;
        }
        interface RegExpLiteral extends Omit<Literal, "type" | "value"> {
            type: "RegExpLiteral";
            pattern: string;
            flags: string;
            value?: RegExp;
        }
        interface ObjectMethod extends Omit<Node, "type">, Omit<Function, "type" | "params" | "body" | "generator" | "async"> {
            type: "ObjectMethod";
            kind: "method" | "get" | "set";
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            params: K.PatternKind[];
            body: K.BlockStatementKind;
            computed?: boolean;
            generator?: boolean;
            async?: boolean;
            accessibility?: K.LiteralKind | null;
            decorators?: K.DecoratorKind[] | null;
        }
        interface ClassMethod extends Omit<Declaration, "type">, Omit<Function, "type" | "body"> {
            type: "ClassMethod";
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            kind?: "get" | "set" | "method" | "constructor";
            body: K.BlockStatementKind;
            computed?: boolean;
            static?: boolean | null;
            abstract?: boolean | null;
            access?: "public" | "private" | "protected" | null;
            accessibility?: "public" | "private" | "protected" | null;
            decorators?: K.DecoratorKind[] | null;
            optional?: boolean | null;
        }
        interface ClassPrivateMethod extends Omit<Declaration, "type">, Omit<Function, "type" | "body"> {
            type: "ClassPrivateMethod";
            key: K.PrivateNameKind;
            kind?: "get" | "set" | "method" | "constructor";
            body: K.BlockStatementKind;
            computed?: boolean;
            static?: boolean | null;
            abstract?: boolean | null;
            access?: "public" | "private" | "protected" | null;
            accessibility?: "public" | "private" | "protected" | null;
            decorators?: K.DecoratorKind[] | null;
            optional?: boolean | null;
        }
        interface RestProperty extends Omit<Node, "type"> {
            type: "RestProperty";
            argument: K.ExpressionKind;
        }
        interface ForAwaitStatement extends Omit<Statement, "type"> {
            type: "ForAwaitStatement";
            left: K.VariableDeclarationKind | K.ExpressionKind;
            right: K.ExpressionKind;
            body: K.StatementKind;
        }
        interface Import extends Omit<Expression, "type"> {
            type: "Import";
        }
        interface TSQualifiedName extends Omit<Node, "type"> {
            type: "TSQualifiedName";
            left: K.IdentifierKind | K.TSQualifiedNameKind;
            right: K.IdentifierKind | K.TSQualifiedNameKind;
        }
        interface TSTypeReference extends Omit<TSType, "type">, TSHasOptionalTypeParameterInstantiation {
            type: "TSTypeReference";
            typeName: K.IdentifierKind | K.TSQualifiedNameKind;
        }
        interface TSHasOptionalTypeParameters {
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }
        interface TSHasOptionalTypeAnnotation {
            typeAnnotation?: K.TSTypeAnnotationKind | null;
        }
        interface TSAsExpression extends Omit<Expression, "type">, Omit<Pattern, "type"> {
            type: "TSAsExpression";
            expression: K.ExpressionKind;
            typeAnnotation: K.TSTypeKind;
            extra?: {
                parenthesized: boolean;
            } | null;
        }
        interface TSNonNullExpression extends Omit<Expression, "type">, Omit<Pattern, "type"> {
            type: "TSNonNullExpression";
            expression: K.ExpressionKind;
        }
        interface TSAnyKeyword extends Omit<TSType, "type"> {
            type: "TSAnyKeyword";
        }
        interface TSBigIntKeyword extends Omit<TSType, "type"> {
            type: "TSBigIntKeyword";
        }
        interface TSBooleanKeyword extends Omit<TSType, "type"> {
            type: "TSBooleanKeyword";
        }
        interface TSNeverKeyword extends Omit<TSType, "type"> {
            type: "TSNeverKeyword";
        }
        interface TSNullKeyword extends Omit<TSType, "type"> {
            type: "TSNullKeyword";
        }
        interface TSNumberKeyword extends Omit<TSType, "type"> {
            type: "TSNumberKeyword";
        }
        interface TSObjectKeyword extends Omit<TSType, "type"> {
            type: "TSObjectKeyword";
        }
        interface TSStringKeyword extends Omit<TSType, "type"> {
            type: "TSStringKeyword";
        }
        interface TSSymbolKeyword extends Omit<TSType, "type"> {
            type: "TSSymbolKeyword";
        }
        interface TSUndefinedKeyword extends Omit<TSType, "type"> {
            type: "TSUndefinedKeyword";
        }
        interface TSUnknownKeyword extends Omit<TSType, "type"> {
            type: "TSUnknownKeyword";
        }
        interface TSVoidKeyword extends Omit<TSType, "type"> {
            type: "TSVoidKeyword";
        }
        interface TSThisType extends Omit<TSType, "type"> {
            type: "TSThisType";
        }
        interface TSArrayType extends Omit<TSType, "type"> {
            type: "TSArrayType";
            elementType: K.TSTypeKind;
        }
        interface TSLiteralType extends Omit<TSType, "type"> {
            type: "TSLiteralType";
            literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind | K.TemplateLiteralKind | K.UnaryExpressionKind;
        }
        interface TSUnionType extends Omit<TSType, "type"> {
            type: "TSUnionType";
            types: K.TSTypeKind[];
        }
        interface TSIntersectionType extends Omit<TSType, "type"> {
            type: "TSIntersectionType";
            types: K.TSTypeKind[];
        }
        interface TSConditionalType extends Omit<TSType, "type"> {
            type: "TSConditionalType";
            checkType: K.TSTypeKind;
            extendsType: K.TSTypeKind;
            trueType: K.TSTypeKind;
            falseType: K.TSTypeKind;
        }
        interface TSInferType extends Omit<TSType, "type"> {
            type: "TSInferType";
            typeParameter: K.TSTypeParameterKind;
        }
        interface TSTypeParameter extends Omit<Identifier, "type" | "name"> {
            type: "TSTypeParameter";
            name: string;
            constraint?: K.TSTypeKind | undefined;
            default?: K.TSTypeKind | undefined;
        }
        interface TSParenthesizedType extends Omit<TSType, "type"> {
            type: "TSParenthesizedType";
            typeAnnotation: K.TSTypeKind;
        }
        interface TSFunctionType extends Omit<TSType, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
            type: "TSFunctionType";
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
        }
        interface TSConstructorType extends Omit<TSType, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
            type: "TSConstructorType";
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
        }
        interface TSDeclareFunction extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
            type: "TSDeclareFunction";
            declare?: boolean;
            async?: boolean;
            generator?: boolean;
            id?: K.IdentifierKind | null;
            params: K.PatternKind[];
            returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
        }
        interface TSDeclareMethod extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
            type: "TSDeclareMethod";
            async?: boolean;
            generator?: boolean;
            params: K.PatternKind[];
            abstract?: boolean;
            accessibility?: "public" | "private" | "protected" | undefined;
            static?: boolean;
            computed?: boolean;
            optional?: boolean;
            key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind;
            kind?: "get" | "set" | "method" | "constructor";
            access?: "public" | "private" | "protected" | undefined;
            decorators?: K.DecoratorKind[] | null;
            returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
        }
        interface TSMappedType extends Omit<TSType, "type"> {
            type: "TSMappedType";
            readonly?: boolean | "+" | "-";
            typeParameter: K.TSTypeParameterKind;
            optional?: boolean | "+" | "-";
            typeAnnotation?: K.TSTypeKind | null;
        }
        interface TSTupleType extends Omit<TSType, "type"> {
            type: "TSTupleType";
            elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[];
        }
        interface TSNamedTupleMember extends Omit<TSType, "type"> {
            type: "TSNamedTupleMember";
            label: K.IdentifierKind;
            optional?: boolean;
            elementType: K.TSTypeKind;
        }
        interface TSRestType extends Omit<TSType, "type"> {
            type: "TSRestType";
            typeAnnotation: K.TSTypeKind;
        }
        interface TSOptionalType extends Omit<TSType, "type"> {
            type: "TSOptionalType";
            typeAnnotation: K.TSTypeKind;
        }
        interface TSIndexedAccessType extends Omit<TSType, "type"> {
            type: "TSIndexedAccessType";
            objectType: K.TSTypeKind;
            indexType: K.TSTypeKind;
        }
        interface TSTypeOperator extends Omit<TSType, "type"> {
            type: "TSTypeOperator";
            operator: string;
            typeAnnotation: K.TSTypeKind;
        }
        interface TSIndexSignature extends Omit<Declaration, "type">, TSHasOptionalTypeAnnotation {
            type: "TSIndexSignature";
            parameters: K.IdentifierKind[];
            readonly?: boolean;
        }
        interface TSPropertySignature extends Omit<Declaration, "type">, TSHasOptionalTypeAnnotation {
            type: "TSPropertySignature";
            key: K.ExpressionKind;
            computed?: boolean;
            readonly?: boolean;
            optional?: boolean;
            initializer?: K.ExpressionKind | null;
        }
        interface TSMethodSignature extends Omit<Declaration, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
            type: "TSMethodSignature";
            key: K.ExpressionKind;
            computed?: boolean;
            optional?: boolean;
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
        }
        interface TSTypePredicate extends Omit<TSTypeAnnotation, "type" | "typeAnnotation">, Omit<TSType, "type"> {
            type: "TSTypePredicate";
            parameterName: K.IdentifierKind | K.TSThisTypeKind;
            typeAnnotation?: K.TSTypeAnnotationKind | null;
            asserts?: boolean;
        }
        interface TSCallSignatureDeclaration extends Omit<Declaration, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
            type: "TSCallSignatureDeclaration";
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
        }
        interface TSConstructSignatureDeclaration extends Omit<Declaration, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
            type: "TSConstructSignatureDeclaration";
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
        }
        interface TSEnumMember extends Omit<Node, "type"> {
            type: "TSEnumMember";
            id: K.IdentifierKind | K.StringLiteralKind;
            initializer?: K.ExpressionKind | null;
        }
        interface TSTypeQuery extends Omit<TSType, "type"> {
            type: "TSTypeQuery";
            exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind;
        }
        interface TSImportType extends Omit<TSType, "type">, TSHasOptionalTypeParameterInstantiation {
            type: "TSImportType";
            argument: K.StringLiteralKind;
            qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined;
        }
        interface TSTypeLiteral extends Omit<TSType, "type"> {
            type: "TSTypeLiteral";
            members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
        }
        interface TSTypeAssertion extends Omit<Expression, "type">, Omit<Pattern, "type"> {
            type: "TSTypeAssertion";
            typeAnnotation: K.TSTypeKind;
            expression: K.ExpressionKind;
            extra?: {
                parenthesized: boolean;
            } | null;
        }
        interface TSEnumDeclaration extends Omit<Declaration, "type"> {
            type: "TSEnumDeclaration";
            id: K.IdentifierKind;
            const?: boolean;
            declare?: boolean;
            members: K.TSEnumMemberKind[];
            initializer?: K.ExpressionKind | null;
        }
        interface TSTypeAliasDeclaration extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
            type: "TSTypeAliasDeclaration";
            id: K.IdentifierKind;
            declare?: boolean;
            typeAnnotation: K.TSTypeKind;
        }
        interface TSModuleBlock extends Omit<Node, "type"> {
            type: "TSModuleBlock";
            body: K.StatementKind[];
        }
        interface TSModuleDeclaration extends Omit<Declaration, "type"> {
            type: "TSModuleDeclaration";
            id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind;
            declare?: boolean;
            global?: boolean;
            body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null;
        }
        interface TSImportEqualsDeclaration extends Omit<Declaration, "type"> {
            type: "TSImportEqualsDeclaration";
            id: K.IdentifierKind;
            isExport?: boolean;
            moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind;
        }
        interface TSExternalModuleReference extends Omit<Declaration, "type"> {
            type: "TSExternalModuleReference";
            expression: K.StringLiteralKind;
        }
        interface TSExportAssignment extends Omit<Statement, "type"> {
            type: "TSExportAssignment";
            expression: K.ExpressionKind;
        }
        interface TSNamespaceExportDeclaration extends Omit<Declaration, "type"> {
            type: "TSNamespaceExportDeclaration";
            id: K.IdentifierKind;
        }
        interface TSInterfaceBody extends Omit<Node, "type"> {
            type: "TSInterfaceBody";
            body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
        }
        interface TSInterfaceDeclaration extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
            type: "TSInterfaceDeclaration";
            id: K.IdentifierKind | K.TSQualifiedNameKind;
            declare?: boolean;
            extends?: K.TSExpressionWithTypeArgumentsKind[] | null;
            body: K.TSInterfaceBodyKind;
        }
        interface TSParameterProperty extends Omit<Pattern, "type"> {
            type: "TSParameterProperty";
            accessibility?: "public" | "private" | "protected" | undefined;
            readonly?: boolean;
            parameter: K.IdentifierKind | K.AssignmentPatternKind;
        }
        type ASTNode = File | Program | Identifier | BlockStatement | EmptyStatement | ExpressionStatement | IfStatement | LabeledStatement | BreakStatement | ContinueStatement | WithStatement | SwitchStatement | SwitchCase | ReturnStatement | ThrowStatement | TryStatement | CatchClause | WhileStatement | DoWhileStatement | ForStatement | VariableDeclaration | ForInStatement | DebuggerStatement | FunctionDeclaration | FunctionExpression | VariableDeclarator | ThisExpression | ArrayExpression | ObjectExpression | Property | Literal | SequenceExpression | UnaryExpression | BinaryExpression | AssignmentExpression | MemberExpression | UpdateExpression | LogicalExpression | ConditionalExpression | NewExpression | CallExpression | RestElement | TypeAnnotation | TSTypeAnnotation | SpreadElementPattern | ArrowFunctionExpression | ForOfStatement | YieldExpression | GeneratorExpression | ComprehensionBlock | ComprehensionExpression | ObjectProperty | PropertyPattern | ObjectPattern | ArrayPattern | SpreadElement | AssignmentPattern | MethodDefinition | ClassPropertyDefinition | ClassProperty | ClassBody | ClassDeclaration | ClassExpression | Super | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportDeclaration | ExportNamedDeclaration | ExportSpecifier | ExportDefaultDeclaration | ExportAllDeclaration | TaggedTemplateExpression | TemplateLiteral | TemplateElement | MetaProperty | AwaitExpression | SpreadProperty | SpreadPropertyPattern | ImportExpression | ChainExpression | OptionalCallExpression | OptionalMemberExpression | JSXAttribute | JSXIdentifier | JSXNamespacedName | JSXExpressionContainer | JSXElement | JSXFragment | JSXMemberExpression | JSXSpreadAttribute | JSXEmptyExpression | JSXText | JSXSpreadChild | JSXOpeningElement | JSXClosingElement | JSXOpeningFragment | JSXClosingFragment | Decorator | PrivateName | ClassPrivateProperty | TypeParameterDeclaration | TSTypeParameterDeclaration | TypeParameterInstantiation | TSTypeParameterInstantiation | ClassImplements | TSExpressionWithTypeArguments | AnyTypeAnnotation | EmptyTypeAnnotation | MixedTypeAnnotation | VoidTypeAnnotation | SymbolTypeAnnotation | NumberTypeAnnotation | BigIntTypeAnnotation | NumberLiteralTypeAnnotation | NumericLiteralTypeAnnotation | BigIntLiteralTypeAnnotation | StringTypeAnnotation | StringLiteralTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullableTypeAnnotation | NullLiteralTypeAnnotation | NullTypeAnnotation | ThisTypeAnnotation | ExistsTypeAnnotation | ExistentialTypeParam | FunctionTypeAnnotation | FunctionTypeParam | ArrayTypeAnnotation | ObjectTypeAnnotation | ObjectTypeProperty | ObjectTypeSpreadProperty | ObjectTypeIndexer | ObjectTypeCallProperty | ObjectTypeInternalSlot | Variance | QualifiedTypeIdentifier | GenericTypeAnnotation | MemberTypeAnnotation | UnionTypeAnnotation | IntersectionTypeAnnotation | TypeofTypeAnnotation | TypeParameter | InterfaceTypeAnnotation | InterfaceExtends | InterfaceDeclaration | DeclareInterface | TypeAlias | DeclareTypeAlias | OpaqueType | DeclareOpaqueType | TypeCastExpression | TupleTypeAnnotation | DeclareVariable | DeclareFunction | DeclareClass | DeclareModule | DeclareModuleExports | DeclareExportDeclaration | ExportBatchSpecifier | DeclareExportAllDeclaration | InferredPredicate | DeclaredPredicate | EnumDeclaration | EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody | EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember | ExportDeclaration | Block | Line | Noop | DoExpression | BindExpression | ParenthesizedExpression | ExportNamespaceSpecifier | ExportDefaultSpecifier | CommentBlock | CommentLine | Directive | DirectiveLiteral | InterpreterDirective | StringLiteral | NumericLiteral | BigIntLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | ObjectMethod | ClassMethod | ClassPrivateMethod | RestProperty | ForAwaitStatement | Import | TSQualifiedName | TSTypeReference | TSAsExpression | TSNonNullExpression | TSAnyKeyword | TSBigIntKeyword | TSBooleanKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSArrayType | TSLiteralType | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSTypeParameter | TSParenthesizedType | TSFunctionType | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSMappedType | TSTupleType | TSNamedTupleMember | TSRestType | TSOptionalType | TSIndexedAccessType | TSTypeOperator | TSIndexSignature | TSPropertySignature | TSMethodSignature | TSTypePredicate | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSEnumMember | TSTypeQuery | TSImportType | TSTypeLiteral | TSTypeAssertion | TSEnumDeclaration | TSTypeAliasDeclaration | TSModuleBlock | TSModuleDeclaration | TSImportEqualsDeclaration | TSExternalModuleReference | TSExportAssignment | TSNamespaceExportDeclaration | TSInterfaceBody | TSInterfaceDeclaration | TSParameterProperty;
        let Printable: Type<Printable>;
        let SourceLocation: Type<SourceLocation>;
        let Node: Type<Node>;
        let Comment: Type<Comment>;
        let Position: Type<Position>;
        let File: Type<File>;
        let Program: Type<Program>;
        let Statement: Type<Statement>;
        let Function: Type<Function>;
        let Expression: Type<Expression>;
        let Pattern: Type<Pattern>;
        let Identifier: Type<Identifier>;
        let BlockStatement: Type<BlockStatement>;
        let EmptyStatement: Type<EmptyStatement>;
        let ExpressionStatement: Type<ExpressionStatement>;
        let IfStatement: Type<IfStatement>;
        let LabeledStatement: Type<LabeledStatement>;
        let BreakStatement: Type<BreakStatement>;
        let ContinueStatement: Type<ContinueStatement>;
        let WithStatement: Type<WithStatement>;
        let SwitchStatement: Type<SwitchStatement>;
        let SwitchCase: Type<SwitchCase>;
        let ReturnStatement: Type<ReturnStatement>;
        let ThrowStatement: Type<ThrowStatement>;
        let TryStatement: Type<TryStatement>;
        let CatchClause: Type<CatchClause>;
        let WhileStatement: Type<WhileStatement>;
        let DoWhileStatement: Type<DoWhileStatement>;
        let ForStatement: Type<ForStatement>;
        let Declaration: Type<Declaration>;
        let VariableDeclaration: Type<VariableDeclaration>;
        let ForInStatement: Type<ForInStatement>;
        let DebuggerStatement: Type<DebuggerStatement>;
        let FunctionDeclaration: Type<FunctionDeclaration>;
        let FunctionExpression: Type<FunctionExpression>;
        let VariableDeclarator: Type<VariableDeclarator>;
        let ThisExpression: Type<ThisExpression>;
        let ArrayExpression: Type<ArrayExpression>;
        let ObjectExpression: Type<ObjectExpression>;
        let Property: Type<Property>;
        let Literal: Type<Literal>;
        let SequenceExpression: Type<SequenceExpression>;
        let UnaryExpression: Type<UnaryExpression>;
        let BinaryExpression: Type<BinaryExpression>;
        let AssignmentExpression: Type<AssignmentExpression>;
        let ChainElement: Type<ChainElement>;
        let MemberExpression: Type<MemberExpression>;
        let UpdateExpression: Type<UpdateExpression>;
        let LogicalExpression: Type<LogicalExpression>;
        let ConditionalExpression: Type<ConditionalExpression>;
        let NewExpression: Type<NewExpression>;
        let CallExpression: Type<CallExpression>;
        let RestElement: Type<RestElement>;
        let TypeAnnotation: Type<TypeAnnotation>;
        let TSTypeAnnotation: Type<TSTypeAnnotation>;
        let SpreadElementPattern: Type<SpreadElementPattern>;
        let ArrowFunctionExpression: Type<ArrowFunctionExpression>;
        let ForOfStatement: Type<ForOfStatement>;
        let YieldExpression: Type<YieldExpression>;
        let GeneratorExpression: Type<GeneratorExpression>;
        let ComprehensionBlock: Type<ComprehensionBlock>;
        let ComprehensionExpression: Type<ComprehensionExpression>;
        let ObjectProperty: Type<ObjectProperty>;
        let PropertyPattern: Type<PropertyPattern>;
        let ObjectPattern: Type<ObjectPattern>;
        let ArrayPattern: Type<ArrayPattern>;
        let SpreadElement: Type<SpreadElement>;
        let AssignmentPattern: Type<AssignmentPattern>;
        let MethodDefinition: Type<MethodDefinition>;
        let ClassPropertyDefinition: Type<ClassPropertyDefinition>;
        let ClassProperty: Type<ClassProperty>;
        let ClassBody: Type<ClassBody>;
        let ClassDeclaration: Type<ClassDeclaration>;
        let ClassExpression: Type<ClassExpression>;
        let Super: Type<Super>;
        let Specifier: Type<Specifier>;
        let ModuleSpecifier: Type<ModuleSpecifier>;
        let ImportSpecifier: Type<ImportSpecifier>;
        let ImportDefaultSpecifier: Type<ImportDefaultSpecifier>;
        let ImportNamespaceSpecifier: Type<ImportNamespaceSpecifier>;
        let ImportDeclaration: Type<ImportDeclaration>;
        let ExportNamedDeclaration: Type<ExportNamedDeclaration>;
        let ExportSpecifier: Type<ExportSpecifier>;
        let ExportDefaultDeclaration: Type<ExportDefaultDeclaration>;
        let ExportAllDeclaration: Type<ExportAllDeclaration>;
        let TaggedTemplateExpression: Type<TaggedTemplateExpression>;
        let TemplateLiteral: Type<TemplateLiteral>;
        let TemplateElement: Type<TemplateElement>;
        let MetaProperty: Type<MetaProperty>;
        let AwaitExpression: Type<AwaitExpression>;
        let SpreadProperty: Type<SpreadProperty>;
        let SpreadPropertyPattern: Type<SpreadPropertyPattern>;
        let ImportExpression: Type<ImportExpression>;
        let ChainExpression: Type<ChainExpression>;
        let OptionalCallExpression: Type<OptionalCallExpression>;
        let OptionalMemberExpression: Type<OptionalMemberExpression>;
        let JSXAttribute: Type<JSXAttribute>;
        let JSXIdentifier: Type<JSXIdentifier>;
        let JSXNamespacedName: Type<JSXNamespacedName>;
        let JSXExpressionContainer: Type<JSXExpressionContainer>;
        let JSXElement: Type<JSXElement>;
        let JSXFragment: Type<JSXFragment>;
        let JSXMemberExpression: Type<JSXMemberExpression>;
        let JSXSpreadAttribute: Type<JSXSpreadAttribute>;
        let JSXEmptyExpression: Type<JSXEmptyExpression>;
        let JSXText: Type<JSXText>;
        let JSXSpreadChild: Type<JSXSpreadChild>;
        let JSXOpeningElement: Type<JSXOpeningElement>;
        let JSXClosingElement: Type<JSXClosingElement>;
        let JSXOpeningFragment: Type<JSXOpeningFragment>;
        let JSXClosingFragment: Type<JSXClosingFragment>;
        let Decorator: Type<Decorator>;
        let PrivateName: Type<PrivateName>;
        let ClassPrivateProperty: Type<ClassPrivateProperty>;
        let TypeParameterDeclaration: Type<TypeParameterDeclaration>;
        let TSTypeParameterDeclaration: Type<TSTypeParameterDeclaration>;
        let TypeParameterInstantiation: Type<TypeParameterInstantiation>;
        let TSTypeParameterInstantiation: Type<TSTypeParameterInstantiation>;
        let ClassImplements: Type<ClassImplements>;
        let TSType: Type<TSType>;
        let TSHasOptionalTypeParameterInstantiation: Type<TSHasOptionalTypeParameterInstantiation>;
        let TSExpressionWithTypeArguments: Type<TSExpressionWithTypeArguments>;
        let Flow: Type<Flow>;
        let FlowType: Type<FlowType>;
        let AnyTypeAnnotation: Type<AnyTypeAnnotation>;
        let EmptyTypeAnnotation: Type<EmptyTypeAnnotation>;
        let MixedTypeAnnotation: Type<MixedTypeAnnotation>;
        let VoidTypeAnnotation: Type<VoidTypeAnnotation>;
        let SymbolTypeAnnotation: Type<SymbolTypeAnnotation>;
        let NumberTypeAnnotation: Type<NumberTypeAnnotation>;
        let BigIntTypeAnnotation: Type<BigIntTypeAnnotation>;
        let NumberLiteralTypeAnnotation: Type<NumberLiteralTypeAnnotation>;
        let NumericLiteralTypeAnnotation: Type<NumericLiteralTypeAnnotation>;
        let BigIntLiteralTypeAnnotation: Type<BigIntLiteralTypeAnnotation>;
        let StringTypeAnnotation: Type<StringTypeAnnotation>;
        let StringLiteralTypeAnnotation: Type<StringLiteralTypeAnnotation>;
        let BooleanTypeAnnotation: Type<BooleanTypeAnnotation>;
        let BooleanLiteralTypeAnnotation: Type<BooleanLiteralTypeAnnotation>;
        let NullableTypeAnnotation: Type<NullableTypeAnnotation>;
        let NullLiteralTypeAnnotation: Type<NullLiteralTypeAnnotation>;
        let NullTypeAnnotation: Type<NullTypeAnnotation>;
        let ThisTypeAnnotation: Type<ThisTypeAnnotation>;
        let ExistsTypeAnnotation: Type<ExistsTypeAnnotation>;
        let ExistentialTypeParam: Type<ExistentialTypeParam>;
        let FunctionTypeAnnotation: Type<FunctionTypeAnnotation>;
        let FunctionTypeParam: Type<FunctionTypeParam>;
        let ArrayTypeAnnotation: Type<ArrayTypeAnnotation>;
        let ObjectTypeAnnotation: Type<ObjectTypeAnnotation>;
        let ObjectTypeProperty: Type<ObjectTypeProperty>;
        let ObjectTypeSpreadProperty: Type<ObjectTypeSpreadProperty>;
        let ObjectTypeIndexer: Type<ObjectTypeIndexer>;
        let ObjectTypeCallProperty: Type<ObjectTypeCallProperty>;
        let ObjectTypeInternalSlot: Type<ObjectTypeInternalSlot>;
        let Variance: Type<Variance>;
        let QualifiedTypeIdentifier: Type<QualifiedTypeIdentifier>;
        let GenericTypeAnnotation: Type<GenericTypeAnnotation>;
        let MemberTypeAnnotation: Type<MemberTypeAnnotation>;
        let UnionTypeAnnotation: Type<UnionTypeAnnotation>;
        let IntersectionTypeAnnotation: Type<IntersectionTypeAnnotation>;
        let TypeofTypeAnnotation: Type<TypeofTypeAnnotation>;
        let TypeParameter: Type<TypeParameter>;
        let InterfaceTypeAnnotation: Type<InterfaceTypeAnnotation>;
        let InterfaceExtends: Type<InterfaceExtends>;
        let InterfaceDeclaration: Type<InterfaceDeclaration>;
        let DeclareInterface: Type<DeclareInterface>;
        let TypeAlias: Type<TypeAlias>;
        let DeclareTypeAlias: Type<DeclareTypeAlias>;
        let OpaqueType: Type<OpaqueType>;
        let DeclareOpaqueType: Type<DeclareOpaqueType>;
        let TypeCastExpression: Type<TypeCastExpression>;
        let TupleTypeAnnotation: Type<TupleTypeAnnotation>;
        let DeclareVariable: Type<DeclareVariable>;
        let DeclareFunction: Type<DeclareFunction>;
        let FlowPredicate: Type<FlowPredicate>;
        let DeclareClass: Type<DeclareClass>;
        let DeclareModule: Type<DeclareModule>;
        let DeclareModuleExports: Type<DeclareModuleExports>;
        let DeclareExportDeclaration: Type<DeclareExportDeclaration>;
        let ExportBatchSpecifier: Type<ExportBatchSpecifier>;
        let DeclareExportAllDeclaration: Type<DeclareExportAllDeclaration>;
        let InferredPredicate: Type<InferredPredicate>;
        let DeclaredPredicate: Type<DeclaredPredicate>;
        let EnumDeclaration: Type<EnumDeclaration>;
        let EnumBooleanBody: Type<EnumBooleanBody>;
        let EnumNumberBody: Type<EnumNumberBody>;
        let EnumStringBody: Type<EnumStringBody>;
        let EnumSymbolBody: Type<EnumSymbolBody>;
        let EnumBooleanMember: Type<EnumBooleanMember>;
        let EnumNumberMember: Type<EnumNumberMember>;
        let EnumStringMember: Type<EnumStringMember>;
        let EnumDefaultedMember: Type<EnumDefaultedMember>;
        let ExportDeclaration: Type<ExportDeclaration>;
        let Block: Type<Block>;
        let Line: Type<Line>;
        let Noop: Type<Noop>;
        let DoExpression: Type<DoExpression>;
        let BindExpression: Type<BindExpression>;
        let ParenthesizedExpression: Type<ParenthesizedExpression>;
        let ExportNamespaceSpecifier: Type<ExportNamespaceSpecifier>;
        let ExportDefaultSpecifier: Type<ExportDefaultSpecifier>;
        let CommentBlock: Type<CommentBlock>;
        let CommentLine: Type<CommentLine>;
        let Directive: Type<Directive>;
        let DirectiveLiteral: Type<DirectiveLiteral>;
        let InterpreterDirective: Type<InterpreterDirective>;
        let StringLiteral: Type<StringLiteral>;
        let NumericLiteral: Type<NumericLiteral>;
        let BigIntLiteral: Type<BigIntLiteral>;
        let NullLiteral: Type<NullLiteral>;
        let BooleanLiteral: Type<BooleanLiteral>;
        let RegExpLiteral: Type<RegExpLiteral>;
        let ObjectMethod: Type<ObjectMethod>;
        let ClassMethod: Type<ClassMethod>;
        let ClassPrivateMethod: Type<ClassPrivateMethod>;
        let RestProperty: Type<RestProperty>;
        let ForAwaitStatement: Type<ForAwaitStatement>;
        let Import: Type<Import>;
        let TSQualifiedName: Type<TSQualifiedName>;
        let TSTypeReference: Type<TSTypeReference>;
        let TSHasOptionalTypeParameters: Type<TSHasOptionalTypeParameters>;
        let TSHasOptionalTypeAnnotation: Type<TSHasOptionalTypeAnnotation>;
        let TSAsExpression: Type<TSAsExpression>;
        let TSNonNullExpression: Type<TSNonNullExpression>;
        let TSAnyKeyword: Type<TSAnyKeyword>;
        let TSBigIntKeyword: Type<TSBigIntKeyword>;
        let TSBooleanKeyword: Type<TSBooleanKeyword>;
        let TSNeverKeyword: Type<TSNeverKeyword>;
        let TSNullKeyword: Type<TSNullKeyword>;
        let TSNumberKeyword: Type<TSNumberKeyword>;
        let TSObjectKeyword: Type<TSObjectKeyword>;
        let TSStringKeyword: Type<TSStringKeyword>;
        let TSSymbolKeyword: Type<TSSymbolKeyword>;
        let TSUndefinedKeyword: Type<TSUndefinedKeyword>;
        let TSUnknownKeyword: Type<TSUnknownKeyword>;
        let TSVoidKeyword: Type<TSVoidKeyword>;
        let TSThisType: Type<TSThisType>;
        let TSArrayType: Type<TSArrayType>;
        let TSLiteralType: Type<TSLiteralType>;
        let TSUnionType: Type<TSUnionType>;
        let TSIntersectionType: Type<TSIntersectionType>;
        let TSConditionalType: Type<TSConditionalType>;
        let TSInferType: Type<TSInferType>;
        let TSTypeParameter: Type<TSTypeParameter>;
        let TSParenthesizedType: Type<TSParenthesizedType>;
        let TSFunctionType: Type<TSFunctionType>;
        let TSConstructorType: Type<TSConstructorType>;
        let TSDeclareFunction: Type<TSDeclareFunction>;
        let TSDeclareMethod: Type<TSDeclareMethod>;
        let TSMappedType: Type<TSMappedType>;
        let TSTupleType: Type<TSTupleType>;
        let TSNamedTupleMember: Type<TSNamedTupleMember>;
        let TSRestType: Type<TSRestType>;
        let TSOptionalType: Type<TSOptionalType>;
        let TSIndexedAccessType: Type<TSIndexedAccessType>;
        let TSTypeOperator: Type<TSTypeOperator>;
        let TSIndexSignature: Type<TSIndexSignature>;
        let TSPropertySignature: Type<TSPropertySignature>;
        let TSMethodSignature: Type<TSMethodSignature>;
        let TSTypePredicate: Type<TSTypePredicate>;
        let TSCallSignatureDeclaration: Type<TSCallSignatureDeclaration>;
        let TSConstructSignatureDeclaration: Type<TSConstructSignatureDeclaration>;
        let TSEnumMember: Type<TSEnumMember>;
        let TSTypeQuery: Type<TSTypeQuery>;
        let TSImportType: Type<TSImportType>;
        let TSTypeLiteral: Type<TSTypeLiteral>;
        let TSTypeAssertion: Type<TSTypeAssertion>;
        let TSEnumDeclaration: Type<TSEnumDeclaration>;
        let TSTypeAliasDeclaration: Type<TSTypeAliasDeclaration>;
        let TSModuleBlock: Type<TSModuleBlock>;
        let TSModuleDeclaration: Type<TSModuleDeclaration>;
        let TSImportEqualsDeclaration: Type<TSImportEqualsDeclaration>;
        let TSExternalModuleReference: Type<TSExternalModuleReference>;
        let TSExportAssignment: Type<TSExportAssignment>;
        let TSNamespaceExportDeclaration: Type<TSNamespaceExportDeclaration>;
        let TSInterfaceBody: Type<TSInterfaceBody>;
        let TSInterfaceDeclaration: Type<TSInterfaceDeclaration>;
        let TSParameterProperty: Type<TSParameterProperty>;
    }
    export interface NamedTypes {
        Printable: Type<namedTypes.Printable>;
        SourceLocation: Type<namedTypes.SourceLocation>;
        Node: Type<namedTypes.Node>;
        Comment: Type<namedTypes.Comment>;
        Position: Type<namedTypes.Position>;
        File: Type<namedTypes.File>;
        Program: Type<namedTypes.Program>;
        Statement: Type<namedTypes.Statement>;
        Function: Type<namedTypes.Function>;
        Expression: Type<namedTypes.Expression>;
        Pattern: Type<namedTypes.Pattern>;
        Identifier: Type<namedTypes.Identifier>;
        BlockStatement: Type<namedTypes.BlockStatement>;
        EmptyStatement: Type<namedTypes.EmptyStatement>;
        ExpressionStatement: Type<namedTypes.ExpressionStatement>;
        IfStatement: Type<namedTypes.IfStatement>;
        LabeledStatement: Type<namedTypes.LabeledStatement>;
        BreakStatement: Type<namedTypes.BreakStatement>;
        ContinueStatement: Type<namedTypes.ContinueStatement>;
        WithStatement: Type<namedTypes.WithStatement>;
        SwitchStatement: Type<namedTypes.SwitchStatement>;
        SwitchCase: Type<namedTypes.SwitchCase>;
        ReturnStatement: Type<namedTypes.ReturnStatement>;
        ThrowStatement: Type<namedTypes.ThrowStatement>;
        TryStatement: Type<namedTypes.TryStatement>;
        CatchClause: Type<namedTypes.CatchClause>;
        WhileStatement: Type<namedTypes.WhileStatement>;
        DoWhileStatement: Type<namedTypes.DoWhileStatement>;
        ForStatement: Type<namedTypes.ForStatement>;
        Declaration: Type<namedTypes.Declaration>;
        VariableDeclaration: Type<namedTypes.VariableDeclaration>;
        ForInStatement: Type<namedTypes.ForInStatement>;
        DebuggerStatement: Type<namedTypes.DebuggerStatement>;
        FunctionDeclaration: Type<namedTypes.FunctionDeclaration>;
        FunctionExpression: Type<namedTypes.FunctionExpression>;
        VariableDeclarator: Type<namedTypes.VariableDeclarator>;
        ThisExpression: Type<namedTypes.ThisExpression>;
        ArrayExpression: Type<namedTypes.ArrayExpression>;
        ObjectExpression: Type<namedTypes.ObjectExpression>;
        Property: Type<namedTypes.Property>;
        Literal: Type<namedTypes.Literal>;
        SequenceExpression: Type<namedTypes.SequenceExpression>;
        UnaryExpression: Type<namedTypes.UnaryExpression>;
        BinaryExpression: Type<namedTypes.BinaryExpression>;
        AssignmentExpression: Type<namedTypes.AssignmentExpression>;
        ChainElement: Type<namedTypes.ChainElement>;
        MemberExpression: Type<namedTypes.MemberExpression>;
        UpdateExpression: Type<namedTypes.UpdateExpression>;
        LogicalExpression: Type<namedTypes.LogicalExpression>;
        ConditionalExpression: Type<namedTypes.ConditionalExpression>;
        NewExpression: Type<namedTypes.NewExpression>;
        CallExpression: Type<namedTypes.CallExpression>;
        RestElement: Type<namedTypes.RestElement>;
        TypeAnnotation: Type<namedTypes.TypeAnnotation>;
        TSTypeAnnotation: Type<namedTypes.TSTypeAnnotation>;
        SpreadElementPattern: Type<namedTypes.SpreadElementPattern>;
        ArrowFunctionExpression: Type<namedTypes.ArrowFunctionExpression>;
        ForOfStatement: Type<namedTypes.ForOfStatement>;
        YieldExpression: Type<namedTypes.YieldExpression>;
        GeneratorExpression: Type<namedTypes.GeneratorExpression>;
        ComprehensionBlock: Type<namedTypes.ComprehensionBlock>;
        ComprehensionExpression: Type<namedTypes.ComprehensionExpression>;
        ObjectProperty: Type<namedTypes.ObjectProperty>;
        PropertyPattern: Type<namedTypes.PropertyPattern>;
        ObjectPattern: Type<namedTypes.ObjectPattern>;
        ArrayPattern: Type<namedTypes.ArrayPattern>;
        SpreadElement: Type<namedTypes.SpreadElement>;
        AssignmentPattern: Type<namedTypes.AssignmentPattern>;
        MethodDefinition: Type<namedTypes.MethodDefinition>;
        ClassPropertyDefinition: Type<namedTypes.ClassPropertyDefinition>;
        ClassProperty: Type<namedTypes.ClassProperty>;
        ClassBody: Type<namedTypes.ClassBody>;
        ClassDeclaration: Type<namedTypes.ClassDeclaration>;
        ClassExpression: Type<namedTypes.ClassExpression>;
        Super: Type<namedTypes.Super>;
        Specifier: Type<namedTypes.Specifier>;
        ModuleSpecifier: Type<namedTypes.ModuleSpecifier>;
        ImportSpecifier: Type<namedTypes.ImportSpecifier>;
        ImportDefaultSpecifier: Type<namedTypes.ImportDefaultSpecifier>;
        ImportNamespaceSpecifier: Type<namedTypes.ImportNamespaceSpecifier>;
        ImportDeclaration: Type<namedTypes.ImportDeclaration>;
        ExportNamedDeclaration: Type<namedTypes.ExportNamedDeclaration>;
        ExportSpecifier: Type<namedTypes.ExportSpecifier>;
        ExportDefaultDeclaration: Type<namedTypes.ExportDefaultDeclaration>;
        ExportAllDeclaration: Type<namedTypes.ExportAllDeclaration>;
        TaggedTemplateExpression: Type<namedTypes.TaggedTemplateExpression>;
        TemplateLiteral: Type<namedTypes.TemplateLiteral>;
        TemplateElement: Type<namedTypes.TemplateElement>;
        MetaProperty: Type<namedTypes.MetaProperty>;
        AwaitExpression: Type<namedTypes.AwaitExpression>;
        SpreadProperty: Type<namedTypes.SpreadProperty>;
        SpreadPropertyPattern: Type<namedTypes.SpreadPropertyPattern>;
        ImportExpression: Type<namedTypes.ImportExpression>;
        ChainExpression: Type<namedTypes.ChainExpression>;
        OptionalCallExpression: Type<namedTypes.OptionalCallExpression>;
        OptionalMemberExpression: Type<namedTypes.OptionalMemberExpression>;
        JSXAttribute: Type<namedTypes.JSXAttribute>;
        JSXIdentifier: Type<namedTypes.JSXIdentifier>;
        JSXNamespacedName: Type<namedTypes.JSXNamespacedName>;
        JSXExpressionContainer: Type<namedTypes.JSXExpressionContainer>;
        JSXElement: Type<namedTypes.JSXElement>;
        JSXFragment: Type<namedTypes.JSXFragment>;
        JSXMemberExpression: Type<namedTypes.JSXMemberExpression>;
        JSXSpreadAttribute: Type<namedTypes.JSXSpreadAttribute>;
        JSXEmptyExpression: Type<namedTypes.JSXEmptyExpression>;
        JSXText: Type<namedTypes.JSXText>;
        JSXSpreadChild: Type<namedTypes.JSXSpreadChild>;
        JSXOpeningElement: Type<namedTypes.JSXOpeningElement>;
        JSXClosingElement: Type<namedTypes.JSXClosingElement>;
        JSXOpeningFragment: Type<namedTypes.JSXOpeningFragment>;
        JSXClosingFragment: Type<namedTypes.JSXClosingFragment>;
        Decorator: Type<namedTypes.Decorator>;
        PrivateName: Type<namedTypes.PrivateName>;
        ClassPrivateProperty: Type<namedTypes.ClassPrivateProperty>;
        TypeParameterDeclaration: Type<namedTypes.TypeParameterDeclaration>;
        TSTypeParameterDeclaration: Type<namedTypes.TSTypeParameterDeclaration>;
        TypeParameterInstantiation: Type<namedTypes.TypeParameterInstantiation>;
        TSTypeParameterInstantiation: Type<namedTypes.TSTypeParameterInstantiation>;
        ClassImplements: Type<namedTypes.ClassImplements>;
        TSType: Type<namedTypes.TSType>;
        TSHasOptionalTypeParameterInstantiation: Type<namedTypes.TSHasOptionalTypeParameterInstantiation>;
        TSExpressionWithTypeArguments: Type<namedTypes.TSExpressionWithTypeArguments>;
        Flow: Type<namedTypes.Flow>;
        FlowType: Type<namedTypes.FlowType>;
        AnyTypeAnnotation: Type<namedTypes.AnyTypeAnnotation>;
        EmptyTypeAnnotation: Type<namedTypes.EmptyTypeAnnotation>;
        MixedTypeAnnotation: Type<namedTypes.MixedTypeAnnotation>;
        VoidTypeAnnotation: Type<namedTypes.VoidTypeAnnotation>;
        SymbolTypeAnnotation: Type<namedTypes.SymbolTypeAnnotation>;
        NumberTypeAnnotation: Type<namedTypes.NumberTypeAnnotation>;
        BigIntTypeAnnotation: Type<namedTypes.BigIntTypeAnnotation>;
        NumberLiteralTypeAnnotation: Type<namedTypes.NumberLiteralTypeAnnotation>;
        NumericLiteralTypeAnnotation: Type<namedTypes.NumericLiteralTypeAnnotation>;
        BigIntLiteralTypeAnnotation: Type<namedTypes.BigIntLiteralTypeAnnotation>;
        StringTypeAnnotation: Type<namedTypes.StringTypeAnnotation>;
        StringLiteralTypeAnnotation: Type<namedTypes.StringLiteralTypeAnnotation>;
        BooleanTypeAnnotation: Type<namedTypes.BooleanTypeAnnotation>;
        BooleanLiteralTypeAnnotation: Type<namedTypes.BooleanLiteralTypeAnnotation>;
        NullableTypeAnnotation: Type<namedTypes.NullableTypeAnnotation>;
        NullLiteralTypeAnnotation: Type<namedTypes.NullLiteralTypeAnnotation>;
        NullTypeAnnotation: Type<namedTypes.NullTypeAnnotation>;
        ThisTypeAnnotation: Type<namedTypes.ThisTypeAnnotation>;
        ExistsTypeAnnotation: Type<namedTypes.ExistsTypeAnnotation>;
        ExistentialTypeParam: Type<namedTypes.ExistentialTypeParam>;
        FunctionTypeAnnotation: Type<namedTypes.FunctionTypeAnnotation>;
        FunctionTypeParam: Type<namedTypes.FunctionTypeParam>;
        ArrayTypeAnnotation: Type<namedTypes.ArrayTypeAnnotation>;
        ObjectTypeAnnotation: Type<namedTypes.ObjectTypeAnnotation>;
        ObjectTypeProperty: Type<namedTypes.ObjectTypeProperty>;
        ObjectTypeSpreadProperty: Type<namedTypes.ObjectTypeSpreadProperty>;
        ObjectTypeIndexer: Type<namedTypes.ObjectTypeIndexer>;
        ObjectTypeCallProperty: Type<namedTypes.ObjectTypeCallProperty>;
        ObjectTypeInternalSlot: Type<namedTypes.ObjectTypeInternalSlot>;
        Variance: Type<namedTypes.Variance>;
        QualifiedTypeIdentifier: Type<namedTypes.QualifiedTypeIdentifier>;
        GenericTypeAnnotation: Type<namedTypes.GenericTypeAnnotation>;
        MemberTypeAnnotation: Type<namedTypes.MemberTypeAnnotation>;
        UnionTypeAnnotation: Type<namedTypes.UnionTypeAnnotation>;
        IntersectionTypeAnnotation: Type<namedTypes.IntersectionTypeAnnotation>;
        TypeofTypeAnnotation: Type<namedTypes.TypeofTypeAnnotation>;
        TypeParameter: Type<namedTypes.TypeParameter>;
        InterfaceTypeAnnotation: Type<namedTypes.InterfaceTypeAnnotation>;
        InterfaceExtends: Type<namedTypes.InterfaceExtends>;
        InterfaceDeclaration: Type<namedTypes.InterfaceDeclaration>;
        DeclareInterface: Type<namedTypes.DeclareInterface>;
        TypeAlias: Type<namedTypes.TypeAlias>;
        DeclareTypeAlias: Type<namedTypes.DeclareTypeAlias>;
        OpaqueType: Type<namedTypes.OpaqueType>;
        DeclareOpaqueType: Type<namedTypes.DeclareOpaqueType>;
        TypeCastExpression: Type<namedTypes.TypeCastExpression>;
        TupleTypeAnnotation: Type<namedTypes.TupleTypeAnnotation>;
        DeclareVariable: Type<namedTypes.DeclareVariable>;
        DeclareFunction: Type<namedTypes.DeclareFunction>;
        FlowPredicate: Type<namedTypes.FlowPredicate>;
        DeclareClass: Type<namedTypes.DeclareClass>;
        DeclareModule: Type<namedTypes.DeclareModule>;
        DeclareModuleExports: Type<namedTypes.DeclareModuleExports>;
        DeclareExportDeclaration: Type<namedTypes.DeclareExportDeclaration>;
        ExportBatchSpecifier: Type<namedTypes.ExportBatchSpecifier>;
        DeclareExportAllDeclaration: Type<namedTypes.DeclareExportAllDeclaration>;
        InferredPredicate: Type<namedTypes.InferredPredicate>;
        DeclaredPredicate: Type<namedTypes.DeclaredPredicate>;
        EnumDeclaration: Type<namedTypes.EnumDeclaration>;
        EnumBooleanBody: Type<namedTypes.EnumBooleanBody>;
        EnumNumberBody: Type<namedTypes.EnumNumberBody>;
        EnumStringBody: Type<namedTypes.EnumStringBody>;
        EnumSymbolBody: Type<namedTypes.EnumSymbolBody>;
        EnumBooleanMember: Type<namedTypes.EnumBooleanMember>;
        EnumNumberMember: Type<namedTypes.EnumNumberMember>;
        EnumStringMember: Type<namedTypes.EnumStringMember>;
        EnumDefaultedMember: Type<namedTypes.EnumDefaultedMember>;
        ExportDeclaration: Type<namedTypes.ExportDeclaration>;
        Block: Type<namedTypes.Block>;
        Line: Type<namedTypes.Line>;
        Noop: Type<namedTypes.Noop>;
        DoExpression: Type<namedTypes.DoExpression>;
        BindExpression: Type<namedTypes.BindExpression>;
        ParenthesizedExpression: Type<namedTypes.ParenthesizedExpression>;
        ExportNamespaceSpecifier: Type<namedTypes.ExportNamespaceSpecifier>;
        ExportDefaultSpecifier: Type<namedTypes.ExportDefaultSpecifier>;
        CommentBlock: Type<namedTypes.CommentBlock>;
        CommentLine: Type<namedTypes.CommentLine>;
        Directive: Type<namedTypes.Directive>;
        DirectiveLiteral: Type<namedTypes.DirectiveLiteral>;
        InterpreterDirective: Type<namedTypes.InterpreterDirective>;
        StringLiteral: Type<namedTypes.StringLiteral>;
        NumericLiteral: Type<namedTypes.NumericLiteral>;
        BigIntLiteral: Type<namedTypes.BigIntLiteral>;
        NullLiteral: Type<namedTypes.NullLiteral>;
        BooleanLiteral: Type<namedTypes.BooleanLiteral>;
        RegExpLiteral: Type<namedTypes.RegExpLiteral>;
        ObjectMethod: Type<namedTypes.ObjectMethod>;
        ClassMethod: Type<namedTypes.ClassMethod>;
        ClassPrivateMethod: Type<namedTypes.ClassPrivateMethod>;
        RestProperty: Type<namedTypes.RestProperty>;
        ForAwaitStatement: Type<namedTypes.ForAwaitStatement>;
        Import: Type<namedTypes.Import>;
        TSQualifiedName: Type<namedTypes.TSQualifiedName>;
        TSTypeReference: Type<namedTypes.TSTypeReference>;
        TSHasOptionalTypeParameters: Type<namedTypes.TSHasOptionalTypeParameters>;
        TSHasOptionalTypeAnnotation: Type<namedTypes.TSHasOptionalTypeAnnotation>;
        TSAsExpression: Type<namedTypes.TSAsExpression>;
        TSNonNullExpression: Type<namedTypes.TSNonNullExpression>;
        TSAnyKeyword: Type<namedTypes.TSAnyKeyword>;
        TSBigIntKeyword: Type<namedTypes.TSBigIntKeyword>;
        TSBooleanKeyword: Type<namedTypes.TSBooleanKeyword>;
        TSNeverKeyword: Type<namedTypes.TSNeverKeyword>;
        TSNullKeyword: Type<namedTypes.TSNullKeyword>;
        TSNumberKeyword: Type<namedTypes.TSNumberKeyword>;
        TSObjectKeyword: Type<namedTypes.TSObjectKeyword>;
        TSStringKeyword: Type<namedTypes.TSStringKeyword>;
        TSSymbolKeyword: Type<namedTypes.TSSymbolKeyword>;
        TSUndefinedKeyword: Type<namedTypes.TSUndefinedKeyword>;
        TSUnknownKeyword: Type<namedTypes.TSUnknownKeyword>;
        TSVoidKeyword: Type<namedTypes.TSVoidKeyword>;
        TSThisType: Type<namedTypes.TSThisType>;
        TSArrayType: Type<namedTypes.TSArrayType>;
        TSLiteralType: Type<namedTypes.TSLiteralType>;
        TSUnionType: Type<namedTypes.TSUnionType>;
        TSIntersectionType: Type<namedTypes.TSIntersectionType>;
        TSConditionalType: Type<namedTypes.TSConditionalType>;
        TSInferType: Type<namedTypes.TSInferType>;
        TSTypeParameter: Type<namedTypes.TSTypeParameter>;
        TSParenthesizedType: Type<namedTypes.TSParenthesizedType>;
        TSFunctionType: Type<namedTypes.TSFunctionType>;
        TSConstructorType: Type<namedTypes.TSConstructorType>;
        TSDeclareFunction: Type<namedTypes.TSDeclareFunction>;
        TSDeclareMethod: Type<namedTypes.TSDeclareMethod>;
        TSMappedType: Type<namedTypes.TSMappedType>;
        TSTupleType: Type<namedTypes.TSTupleType>;
        TSNamedTupleMember: Type<namedTypes.TSNamedTupleMember>;
        TSRestType: Type<namedTypes.TSRestType>;
        TSOptionalType: Type<namedTypes.TSOptionalType>;
        TSIndexedAccessType: Type<namedTypes.TSIndexedAccessType>;
        TSTypeOperator: Type<namedTypes.TSTypeOperator>;
        TSIndexSignature: Type<namedTypes.TSIndexSignature>;
        TSPropertySignature: Type<namedTypes.TSPropertySignature>;
        TSMethodSignature: Type<namedTypes.TSMethodSignature>;
        TSTypePredicate: Type<namedTypes.TSTypePredicate>;
        TSCallSignatureDeclaration: Type<namedTypes.TSCallSignatureDeclaration>;
        TSConstructSignatureDeclaration: Type<namedTypes.TSConstructSignatureDeclaration>;
        TSEnumMember: Type<namedTypes.TSEnumMember>;
        TSTypeQuery: Type<namedTypes.TSTypeQuery>;
        TSImportType: Type<namedTypes.TSImportType>;
        TSTypeLiteral: Type<namedTypes.TSTypeLiteral>;
        TSTypeAssertion: Type<namedTypes.TSTypeAssertion>;
        TSEnumDeclaration: Type<namedTypes.TSEnumDeclaration>;
        TSTypeAliasDeclaration: Type<namedTypes.TSTypeAliasDeclaration>;
        TSModuleBlock: Type<namedTypes.TSModuleBlock>;
        TSModuleDeclaration: Type<namedTypes.TSModuleDeclaration>;
        TSImportEqualsDeclaration: Type<namedTypes.TSImportEqualsDeclaration>;
        TSExternalModuleReference: Type<namedTypes.TSExternalModuleReference>;
        TSExportAssignment: Type<namedTypes.TSExportAssignment>;
        TSNamespaceExportDeclaration: Type<namedTypes.TSNamespaceExportDeclaration>;
        TSInterfaceBody: Type<namedTypes.TSInterfaceBody>;
        TSInterfaceDeclaration: Type<namedTypes.TSInterfaceDeclaration>;
        TSParameterProperty: Type<namedTypes.TSParameterProperty>;
    }
}

declare module 'ast-types/gen/builders' {
    import * as K from "ast-types/gen/kinds";
    import { namedTypes } from "ast-types/gen/namedTypes";
    export interface FileBuilder {
        (program: K.ProgramKind, name?: string | null): namedTypes.File;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name?: string | null;
            program: K.ProgramKind;
        }): namedTypes.File;
    }
    export interface ProgramBuilder {
        (body: K.StatementKind[]): namedTypes.Program;
        from(params: {
            body: K.StatementKind[];
            comments?: K.CommentKind[] | null;
            directives?: K.DirectiveKind[];
            interpreter?: K.InterpreterDirectiveKind | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.Program;
    }
    export interface IdentifierBuilder {
        (name: string): namedTypes.Identifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name: string;
            optional?: boolean;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        }): namedTypes.Identifier;
    }
    export interface BlockStatementBuilder {
        (body: K.StatementKind[]): namedTypes.BlockStatement;
        from(params: {
            body: K.StatementKind[];
            comments?: K.CommentKind[] | null;
            directives?: K.DirectiveKind[];
            loc?: K.SourceLocationKind | null;
        }): namedTypes.BlockStatement;
    }
    export interface EmptyStatementBuilder {
        (): namedTypes.EmptyStatement;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.EmptyStatement;
    }
    export interface ExpressionStatementBuilder {
        (expression: K.ExpressionKind): namedTypes.ExpressionStatement;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ExpressionStatement;
    }
    export interface IfStatementBuilder {
        (test: K.ExpressionKind, consequent: K.StatementKind, alternate?: K.StatementKind | null): namedTypes.IfStatement;
        from(params: {
            alternate?: K.StatementKind | null;
            comments?: K.CommentKind[] | null;
            consequent: K.StatementKind;
            loc?: K.SourceLocationKind | null;
            test: K.ExpressionKind;
        }): namedTypes.IfStatement;
    }
    export interface LabeledStatementBuilder {
        (label: K.IdentifierKind, body: K.StatementKind): namedTypes.LabeledStatement;
        from(params: {
            body: K.StatementKind;
            comments?: K.CommentKind[] | null;
            label: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.LabeledStatement;
    }
    export interface BreakStatementBuilder {
        (label?: K.IdentifierKind | null): namedTypes.BreakStatement;
        from(params: {
            comments?: K.CommentKind[] | null;
            label?: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.BreakStatement;
    }
    export interface ContinueStatementBuilder {
        (label?: K.IdentifierKind | null): namedTypes.ContinueStatement;
        from(params: {
            comments?: K.CommentKind[] | null;
            label?: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ContinueStatement;
    }
    export interface WithStatementBuilder {
        (object: K.ExpressionKind, body: K.StatementKind): namedTypes.WithStatement;
        from(params: {
            body: K.StatementKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            object: K.ExpressionKind;
        }): namedTypes.WithStatement;
    }
    export interface SwitchStatementBuilder {
        (discriminant: K.ExpressionKind, cases: K.SwitchCaseKind[], lexical?: boolean): namedTypes.SwitchStatement;
        from(params: {
            cases: K.SwitchCaseKind[];
            comments?: K.CommentKind[] | null;
            discriminant: K.ExpressionKind;
            lexical?: boolean;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.SwitchStatement;
    }
    export interface SwitchCaseBuilder {
        (test: K.ExpressionKind | null, consequent: K.StatementKind[]): namedTypes.SwitchCase;
        from(params: {
            comments?: K.CommentKind[] | null;
            consequent: K.StatementKind[];
            loc?: K.SourceLocationKind | null;
            test: K.ExpressionKind | null;
        }): namedTypes.SwitchCase;
    }
    export interface ReturnStatementBuilder {
        (argument: K.ExpressionKind | null): namedTypes.ReturnStatement;
        from(params: {
            argument: K.ExpressionKind | null;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ReturnStatement;
    }
    export interface ThrowStatementBuilder {
        (argument: K.ExpressionKind): namedTypes.ThrowStatement;
        from(params: {
            argument: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ThrowStatement;
    }
    export interface TryStatementBuilder {
        (block: K.BlockStatementKind, handler?: K.CatchClauseKind | null, finalizer?: K.BlockStatementKind | null): namedTypes.TryStatement;
        from(params: {
            block: K.BlockStatementKind;
            comments?: K.CommentKind[] | null;
            finalizer?: K.BlockStatementKind | null;
            guardedHandlers?: K.CatchClauseKind[];
            handler?: K.CatchClauseKind | null;
            handlers?: K.CatchClauseKind[];
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TryStatement;
    }
    export interface CatchClauseBuilder {
        (param: K.PatternKind | null | undefined, guard: K.ExpressionKind | null | undefined, body: K.BlockStatementKind): namedTypes.CatchClause;
        from(params: {
            body: K.BlockStatementKind;
            comments?: K.CommentKind[] | null;
            guard?: K.ExpressionKind | null;
            loc?: K.SourceLocationKind | null;
            param?: K.PatternKind | null;
        }): namedTypes.CatchClause;
    }
    export interface WhileStatementBuilder {
        (test: K.ExpressionKind, body: K.StatementKind): namedTypes.WhileStatement;
        from(params: {
            body: K.StatementKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            test: K.ExpressionKind;
        }): namedTypes.WhileStatement;
    }
    export interface DoWhileStatementBuilder {
        (body: K.StatementKind, test: K.ExpressionKind): namedTypes.DoWhileStatement;
        from(params: {
            body: K.StatementKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            test: K.ExpressionKind;
        }): namedTypes.DoWhileStatement;
    }
    export interface ForStatementBuilder {
        (init: K.VariableDeclarationKind | K.ExpressionKind | null, test: K.ExpressionKind | null, update: K.ExpressionKind | null, body: K.StatementKind): namedTypes.ForStatement;
        from(params: {
            body: K.StatementKind;
            comments?: K.CommentKind[] | null;
            init: K.VariableDeclarationKind | K.ExpressionKind | null;
            loc?: K.SourceLocationKind | null;
            test: K.ExpressionKind | null;
            update: K.ExpressionKind | null;
        }): namedTypes.ForStatement;
    }
    export interface VariableDeclarationBuilder {
        (kind: "var" | "let" | "const", declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[]): namedTypes.VariableDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[];
            kind: "var" | "let" | "const";
            loc?: K.SourceLocationKind | null;
        }): namedTypes.VariableDeclaration;
    }
    export interface ForInStatementBuilder {
        (left: K.VariableDeclarationKind | K.ExpressionKind, right: K.ExpressionKind, body: K.StatementKind): namedTypes.ForInStatement;
        from(params: {
            body: K.StatementKind;
            comments?: K.CommentKind[] | null;
            left: K.VariableDeclarationKind | K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            right: K.ExpressionKind;
        }): namedTypes.ForInStatement;
    }
    export interface DebuggerStatementBuilder {
        (): namedTypes.DebuggerStatement;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.DebuggerStatement;
    }
    export interface FunctionDeclarationBuilder {
        (id: K.IdentifierKind | null, params: K.PatternKind[], body: K.BlockStatementKind, generator?: boolean, expression?: boolean): namedTypes.FunctionDeclaration;
        from(params: {
            async?: boolean;
            body: K.BlockStatementKind;
            comments?: K.CommentKind[] | null;
            defaults?: (K.ExpressionKind | null)[];
            expression?: boolean;
            generator?: boolean;
            id: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
            params: K.PatternKind[];
            predicate?: K.FlowPredicateKind | null;
            rest?: K.IdentifierKind | null;
            returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        }): namedTypes.FunctionDeclaration;
    }
    export interface FunctionExpressionBuilder {
        (id: K.IdentifierKind | null | undefined, params: K.PatternKind[], body: K.BlockStatementKind, generator?: boolean, expression?: boolean): namedTypes.FunctionExpression;
        from(params: {
            async?: boolean;
            body: K.BlockStatementKind;
            comments?: K.CommentKind[] | null;
            defaults?: (K.ExpressionKind | null)[];
            expression?: boolean;
            generator?: boolean;
            id?: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
            params: K.PatternKind[];
            predicate?: K.FlowPredicateKind | null;
            rest?: K.IdentifierKind | null;
            returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        }): namedTypes.FunctionExpression;
    }
    export interface VariableDeclaratorBuilder {
        (id: K.PatternKind, init?: K.ExpressionKind | null): namedTypes.VariableDeclarator;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.PatternKind;
            init?: K.ExpressionKind | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.VariableDeclarator;
    }
    export interface ThisExpressionBuilder {
        (): namedTypes.ThisExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ThisExpression;
    }
    export interface ArrayExpressionBuilder {
        (elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[]): namedTypes.ArrayExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[];
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ArrayExpression;
    }
    export interface ObjectExpressionBuilder {
        (properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[]): namedTypes.ObjectExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[];
        }): namedTypes.ObjectExpression;
    }
    export interface PropertyBuilder {
        (kind: "init" | "get" | "set", key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, value: K.ExpressionKind | K.PatternKind): namedTypes.Property;
        from(params: {
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            decorators?: K.DecoratorKind[] | null;
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            kind: "init" | "get" | "set";
            loc?: K.SourceLocationKind | null;
            method?: boolean;
            shorthand?: boolean;
            value: K.ExpressionKind | K.PatternKind;
        }): namedTypes.Property;
    }
    export interface LiteralBuilder {
        (value: string | boolean | null | number | RegExp): namedTypes.Literal;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
            value: string | boolean | null | number | RegExp;
        }): namedTypes.Literal;
    }
    export interface SequenceExpressionBuilder {
        (expressions: K.ExpressionKind[]): namedTypes.SequenceExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            expressions: K.ExpressionKind[];
            loc?: K.SourceLocationKind | null;
        }): namedTypes.SequenceExpression;
    }
    export interface UnaryExpressionBuilder {
        (operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete", argument: K.ExpressionKind, prefix?: boolean): namedTypes.UnaryExpression;
        from(params: {
            argument: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
            prefix?: boolean;
        }): namedTypes.UnaryExpression;
    }
    export interface BinaryExpressionBuilder {
        (operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "in" | "instanceof" | "**", left: K.ExpressionKind, right: K.ExpressionKind): namedTypes.BinaryExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            left: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "in" | "instanceof" | "**";
            right: K.ExpressionKind;
        }): namedTypes.BinaryExpression;
    }
    export interface AssignmentExpressionBuilder {
        (operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=", left: K.PatternKind | K.MemberExpressionKind, right: K.ExpressionKind): namedTypes.AssignmentExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            left: K.PatternKind | K.MemberExpressionKind;
            loc?: K.SourceLocationKind | null;
            operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=";
            right: K.ExpressionKind;
        }): namedTypes.AssignmentExpression;
    }
    export interface MemberExpressionBuilder {
        (object: K.ExpressionKind, property: K.IdentifierKind | K.ExpressionKind, computed?: boolean): namedTypes.MemberExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            loc?: K.SourceLocationKind | null;
            object: K.ExpressionKind;
            optional?: boolean;
            property: K.IdentifierKind | K.ExpressionKind;
        }): namedTypes.MemberExpression;
    }
    export interface UpdateExpressionBuilder {
        (operator: "++" | "--", argument: K.ExpressionKind, prefix: boolean): namedTypes.UpdateExpression;
        from(params: {
            argument: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            operator: "++" | "--";
            prefix: boolean;
        }): namedTypes.UpdateExpression;
    }
    export interface LogicalExpressionBuilder {
        (operator: "||" | "&&" | "??", left: K.ExpressionKind, right: K.ExpressionKind): namedTypes.LogicalExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            left: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            operator: "||" | "&&" | "??";
            right: K.ExpressionKind;
        }): namedTypes.LogicalExpression;
    }
    export interface ConditionalExpressionBuilder {
        (test: K.ExpressionKind, consequent: K.ExpressionKind, alternate: K.ExpressionKind): namedTypes.ConditionalExpression;
        from(params: {
            alternate: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            consequent: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            test: K.ExpressionKind;
        }): namedTypes.ConditionalExpression;
    }
    export interface NewExpressionBuilder {
        (callee: K.ExpressionKind, argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[]): namedTypes.NewExpression;
        from(params: {
            arguments: (K.ExpressionKind | K.SpreadElementKind)[];
            callee: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeArguments?: null | K.TypeParameterInstantiationKind;
        }): namedTypes.NewExpression;
    }
    export interface CallExpressionBuilder {
        (callee: K.ExpressionKind, argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[]): namedTypes.CallExpression;
        from(params: {
            arguments: (K.ExpressionKind | K.SpreadElementKind)[];
            callee: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            optional?: boolean;
            typeArguments?: null | K.TypeParameterInstantiationKind;
        }): namedTypes.CallExpression;
    }
    export interface RestElementBuilder {
        (argument: K.PatternKind): namedTypes.RestElement;
        from(params: {
            argument: K.PatternKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        }): namedTypes.RestElement;
    }
    export interface TypeAnnotationBuilder {
        (typeAnnotation: K.FlowTypeKind): namedTypes.TypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.FlowTypeKind;
        }): namedTypes.TypeAnnotation;
    }
    export interface TSTypeAnnotationBuilder {
        (typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind): namedTypes.TSTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind;
        }): namedTypes.TSTypeAnnotation;
    }
    export interface SpreadElementPatternBuilder {
        (argument: K.PatternKind): namedTypes.SpreadElementPattern;
        from(params: {
            argument: K.PatternKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.SpreadElementPattern;
    }
    export interface ArrowFunctionExpressionBuilder {
        (params: K.PatternKind[], body: K.BlockStatementKind | K.ExpressionKind, expression?: boolean): namedTypes.ArrowFunctionExpression;
        from(params: {
            async?: boolean;
            body: K.BlockStatementKind | K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            defaults?: (K.ExpressionKind | null)[];
            expression?: boolean;
            generator?: false;
            id?: null;
            loc?: K.SourceLocationKind | null;
            params: K.PatternKind[];
            predicate?: K.FlowPredicateKind | null;
            rest?: K.IdentifierKind | null;
            returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        }): namedTypes.ArrowFunctionExpression;
    }
    export interface ForOfStatementBuilder {
        (left: K.VariableDeclarationKind | K.PatternKind, right: K.ExpressionKind, body: K.StatementKind): namedTypes.ForOfStatement;
        from(params: {
            await?: boolean;
            body: K.StatementKind;
            comments?: K.CommentKind[] | null;
            left: K.VariableDeclarationKind | K.PatternKind;
            loc?: K.SourceLocationKind | null;
            right: K.ExpressionKind;
        }): namedTypes.ForOfStatement;
    }
    export interface YieldExpressionBuilder {
        (argument: K.ExpressionKind | null, delegate?: boolean): namedTypes.YieldExpression;
        from(params: {
            argument: K.ExpressionKind | null;
            comments?: K.CommentKind[] | null;
            delegate?: boolean;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.YieldExpression;
    }
    export interface GeneratorExpressionBuilder {
        (body: K.ExpressionKind, blocks: K.ComprehensionBlockKind[], filter: K.ExpressionKind | null): namedTypes.GeneratorExpression;
        from(params: {
            blocks: K.ComprehensionBlockKind[];
            body: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            filter: K.ExpressionKind | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.GeneratorExpression;
    }
    export interface ComprehensionBlockBuilder {
        (left: K.PatternKind, right: K.ExpressionKind, each: boolean): namedTypes.ComprehensionBlock;
        from(params: {
            comments?: K.CommentKind[] | null;
            each: boolean;
            left: K.PatternKind;
            loc?: K.SourceLocationKind | null;
            right: K.ExpressionKind;
        }): namedTypes.ComprehensionBlock;
    }
    export interface ComprehensionExpressionBuilder {
        (body: K.ExpressionKind, blocks: K.ComprehensionBlockKind[], filter: K.ExpressionKind | null): namedTypes.ComprehensionExpression;
        from(params: {
            blocks: K.ComprehensionBlockKind[];
            body: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            filter: K.ExpressionKind | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ComprehensionExpression;
    }
    export interface ObjectPropertyBuilder {
        (key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, value: K.ExpressionKind | K.PatternKind): namedTypes.ObjectProperty;
        from(params: {
            accessibility?: K.LiteralKind | null;
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            shorthand?: boolean;
            value: K.ExpressionKind | K.PatternKind;
        }): namedTypes.ObjectProperty;
    }
    export interface PropertyPatternBuilder {
        (key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, pattern: K.PatternKind): namedTypes.PropertyPattern;
        from(params: {
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            pattern: K.PatternKind;
        }): namedTypes.PropertyPattern;
    }
    export interface ObjectPatternBuilder {
        (properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind)[]): namedTypes.ObjectPattern;
        from(params: {
            comments?: K.CommentKind[] | null;
            decorators?: K.DecoratorKind[] | null;
            loc?: K.SourceLocationKind | null;
            properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind)[];
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        }): namedTypes.ObjectPattern;
    }
    export interface ArrayPatternBuilder {
        (elements: (K.PatternKind | K.SpreadElementKind | null)[]): namedTypes.ArrayPattern;
        from(params: {
            comments?: K.CommentKind[] | null;
            elements: (K.PatternKind | K.SpreadElementKind | null)[];
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ArrayPattern;
    }
    export interface SpreadElementBuilder {
        (argument: K.ExpressionKind): namedTypes.SpreadElement;
        from(params: {
            argument: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.SpreadElement;
    }
    export interface AssignmentPatternBuilder {
        (left: K.PatternKind, right: K.ExpressionKind): namedTypes.AssignmentPattern;
        from(params: {
            comments?: K.CommentKind[] | null;
            left: K.PatternKind;
            loc?: K.SourceLocationKind | null;
            right: K.ExpressionKind;
        }): namedTypes.AssignmentPattern;
    }
    export interface MethodDefinitionBuilder {
        (kind: "constructor" | "method" | "get" | "set", key: K.ExpressionKind, value: K.FunctionKind, staticParam?: boolean): namedTypes.MethodDefinition;
        from(params: {
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            decorators?: K.DecoratorKind[] | null;
            key: K.ExpressionKind;
            kind: "constructor" | "method" | "get" | "set";
            loc?: K.SourceLocationKind | null;
            static?: boolean;
            value: K.FunctionKind;
        }): namedTypes.MethodDefinition;
    }
    export interface ClassPropertyDefinitionBuilder {
        (definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind): namedTypes.ClassPropertyDefinition;
        from(params: {
            comments?: K.CommentKind[] | null;
            definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ClassPropertyDefinition;
    }
    export interface ClassPropertyBuilder {
        (key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, value: K.ExpressionKind | null, typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null, staticParam?: boolean): namedTypes.ClassProperty;
        from(params: {
            access?: "public" | "private" | "protected" | undefined;
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            static?: boolean;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            value: K.ExpressionKind | null;
            variance?: K.VarianceKind | "plus" | "minus" | null;
        }): namedTypes.ClassProperty;
    }
    export interface ClassBodyBuilder {
        (body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassPrivatePropertyKind | K.ClassMethodKind | K.ClassPrivateMethodKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]): namedTypes.ClassBody;
        from(params: {
            body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassPrivatePropertyKind | K.ClassMethodKind | K.ClassPrivateMethodKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ClassBody;
    }
    export interface ClassDeclarationBuilder {
        (id: K.IdentifierKind | null, body: K.ClassBodyKind, superClass?: K.ExpressionKind | null): namedTypes.ClassDeclaration;
        from(params: {
            body: K.ClassBodyKind;
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind | null;
            implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
            loc?: K.SourceLocationKind | null;
            superClass?: K.ExpressionKind | null;
            superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        }): namedTypes.ClassDeclaration;
    }
    export interface ClassExpressionBuilder {
        (id: K.IdentifierKind | null | undefined, body: K.ClassBodyKind, superClass?: K.ExpressionKind | null): namedTypes.ClassExpression;
        from(params: {
            body: K.ClassBodyKind;
            comments?: K.CommentKind[] | null;
            id?: K.IdentifierKind | null;
            implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
            loc?: K.SourceLocationKind | null;
            superClass?: K.ExpressionKind | null;
            superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        }): namedTypes.ClassExpression;
    }
    export interface SuperBuilder {
        (): namedTypes.Super;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.Super;
    }
    export interface ImportSpecifierBuilder {
        (imported: K.IdentifierKind, local?: K.IdentifierKind | null): namedTypes.ImportSpecifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            id?: K.IdentifierKind | null;
            imported: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            local?: K.IdentifierKind | null;
            name?: K.IdentifierKind | null;
        }): namedTypes.ImportSpecifier;
    }
    export interface ImportDefaultSpecifierBuilder {
        (local?: K.IdentifierKind | null): namedTypes.ImportDefaultSpecifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            id?: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
            local?: K.IdentifierKind | null;
            name?: K.IdentifierKind | null;
        }): namedTypes.ImportDefaultSpecifier;
    }
    export interface ImportNamespaceSpecifierBuilder {
        (local?: K.IdentifierKind | null): namedTypes.ImportNamespaceSpecifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            id?: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
            local?: K.IdentifierKind | null;
            name?: K.IdentifierKind | null;
        }): namedTypes.ImportNamespaceSpecifier;
    }
    export interface ImportDeclarationBuilder {
        (specifiers: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[] | undefined, source: K.LiteralKind, importKind?: "value" | "type" | "typeof"): namedTypes.ImportDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            importKind?: "value" | "type" | "typeof";
            loc?: K.SourceLocationKind | null;
            source: K.LiteralKind;
            specifiers?: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[];
        }): namedTypes.ImportDeclaration;
    }
    export interface ExportNamedDeclarationBuilder {
        (declaration: K.DeclarationKind | null, specifiers?: K.ExportSpecifierKind[], source?: K.LiteralKind | null): namedTypes.ExportNamedDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            declaration: K.DeclarationKind | null;
            loc?: K.SourceLocationKind | null;
            source?: K.LiteralKind | null;
            specifiers?: K.ExportSpecifierKind[];
        }): namedTypes.ExportNamedDeclaration;
    }
    export interface ExportSpecifierBuilder {
        (id?: K.IdentifierKind | null, name?: K.IdentifierKind | null): namedTypes.ExportSpecifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            exported: K.IdentifierKind;
            id?: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
            local?: K.IdentifierKind | null;
            name?: K.IdentifierKind | null;
        }): namedTypes.ExportSpecifier;
    }
    export interface ExportDefaultDeclarationBuilder {
        (declaration: K.DeclarationKind | K.ExpressionKind): namedTypes.ExportDefaultDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            declaration: K.DeclarationKind | K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ExportDefaultDeclaration;
    }
    export interface ExportAllDeclarationBuilder {
        (source: K.LiteralKind, exported: K.IdentifierKind | null): namedTypes.ExportAllDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            exported: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
            source: K.LiteralKind;
        }): namedTypes.ExportAllDeclaration;
    }
    export interface TaggedTemplateExpressionBuilder {
        (tag: K.ExpressionKind, quasi: K.TemplateLiteralKind): namedTypes.TaggedTemplateExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            quasi: K.TemplateLiteralKind;
            tag: K.ExpressionKind;
        }): namedTypes.TaggedTemplateExpression;
    }
    export interface TemplateLiteralBuilder {
        (quasis: K.TemplateElementKind[], expressions: K.ExpressionKind[]): namedTypes.TemplateLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            expressions: K.ExpressionKind[];
            loc?: K.SourceLocationKind | null;
            quasis: K.TemplateElementKind[];
        }): namedTypes.TemplateLiteral;
    }
    export interface TemplateElementBuilder {
        (value: {
            cooked: string | null;
            raw: string;
        }, tail: boolean): namedTypes.TemplateElement;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            tail: boolean;
            value: {
                cooked: string | null;
                raw: string;
            };
        }): namedTypes.TemplateElement;
    }
    export interface MetaPropertyBuilder {
        (meta: K.IdentifierKind, property: K.IdentifierKind): namedTypes.MetaProperty;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            meta: K.IdentifierKind;
            property: K.IdentifierKind;
        }): namedTypes.MetaProperty;
    }
    export interface AwaitExpressionBuilder {
        (argument: K.ExpressionKind | null, all?: boolean): namedTypes.AwaitExpression;
        from(params: {
            all?: boolean;
            argument: K.ExpressionKind | null;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.AwaitExpression;
    }
    export interface SpreadPropertyBuilder {
        (argument: K.ExpressionKind): namedTypes.SpreadProperty;
        from(params: {
            argument: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.SpreadProperty;
    }
    export interface SpreadPropertyPatternBuilder {
        (argument: K.PatternKind): namedTypes.SpreadPropertyPattern;
        from(params: {
            argument: K.PatternKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.SpreadPropertyPattern;
    }
    export interface ImportExpressionBuilder {
        (source: K.ExpressionKind): namedTypes.ImportExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            source: K.ExpressionKind;
        }): namedTypes.ImportExpression;
    }
    export interface ChainExpressionBuilder {
        (expression: K.ChainElementKind): namedTypes.ChainExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ChainElementKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ChainExpression;
    }
    export interface OptionalCallExpressionBuilder {
        (callee: K.ExpressionKind, argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[], optional?: boolean): namedTypes.OptionalCallExpression;
        from(params: {
            arguments: (K.ExpressionKind | K.SpreadElementKind)[];
            callee: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            optional?: boolean;
            typeArguments?: null | K.TypeParameterInstantiationKind;
        }): namedTypes.OptionalCallExpression;
    }
    export interface OptionalMemberExpressionBuilder {
        (object: K.ExpressionKind, property: K.IdentifierKind | K.ExpressionKind, computed?: boolean, optional?: boolean): namedTypes.OptionalMemberExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            loc?: K.SourceLocationKind | null;
            object: K.ExpressionKind;
            optional?: boolean;
            property: K.IdentifierKind | K.ExpressionKind;
        }): namedTypes.OptionalMemberExpression;
    }
    export interface JSXAttributeBuilder {
        (name: K.JSXIdentifierKind | K.JSXNamespacedNameKind, value?: K.LiteralKind | K.JSXExpressionContainerKind | K.JSXElementKind | K.JSXFragmentKind | null): namedTypes.JSXAttribute;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name: K.JSXIdentifierKind | K.JSXNamespacedNameKind;
            value?: K.LiteralKind | K.JSXExpressionContainerKind | K.JSXElementKind | K.JSXFragmentKind | null;
        }): namedTypes.JSXAttribute;
    }
    export interface JSXIdentifierBuilder {
        (name: string): namedTypes.JSXIdentifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name: string;
            optional?: boolean;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        }): namedTypes.JSXIdentifier;
    }
    export interface JSXNamespacedNameBuilder {
        (namespace: K.JSXIdentifierKind, name: K.JSXIdentifierKind): namedTypes.JSXNamespacedName;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name: K.JSXIdentifierKind;
            namespace: K.JSXIdentifierKind;
        }): namedTypes.JSXNamespacedName;
    }
    export interface JSXExpressionContainerBuilder {
        (expression: K.ExpressionKind | K.JSXEmptyExpressionKind): namedTypes.JSXExpressionContainer;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind | K.JSXEmptyExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.JSXExpressionContainer;
    }
    export interface JSXElementBuilder {
        (openingElement: K.JSXOpeningElementKind, closingElement?: K.JSXClosingElementKind | null, children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[]): namedTypes.JSXElement;
        from(params: {
            attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
            children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
            closingElement?: K.JSXClosingElementKind | null;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name?: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
            openingElement: K.JSXOpeningElementKind;
            selfClosing?: boolean;
        }): namedTypes.JSXElement;
    }
    export interface JSXFragmentBuilder {
        (openingFragment: K.JSXOpeningFragmentKind, closingFragment: K.JSXClosingFragmentKind, children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[]): namedTypes.JSXFragment;
        from(params: {
            children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
            closingFragment: K.JSXClosingFragmentKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            openingFragment: K.JSXOpeningFragmentKind;
        }): namedTypes.JSXFragment;
    }
    export interface JSXMemberExpressionBuilder {
        (object: K.JSXIdentifierKind | K.JSXMemberExpressionKind, property: K.JSXIdentifierKind): namedTypes.JSXMemberExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            loc?: K.SourceLocationKind | null;
            object: K.JSXIdentifierKind | K.JSXMemberExpressionKind;
            optional?: boolean;
            property: K.JSXIdentifierKind;
        }): namedTypes.JSXMemberExpression;
    }
    export interface JSXSpreadAttributeBuilder {
        (argument: K.ExpressionKind): namedTypes.JSXSpreadAttribute;
        from(params: {
            argument: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.JSXSpreadAttribute;
    }
    export interface JSXEmptyExpressionBuilder {
        (): namedTypes.JSXEmptyExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.JSXEmptyExpression;
    }
    export interface JSXTextBuilder {
        (value: string, raw?: string): namedTypes.JSXText;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            raw?: string;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
            value: string;
        }): namedTypes.JSXText;
    }
    export interface JSXSpreadChildBuilder {
        (expression: K.ExpressionKind): namedTypes.JSXSpreadChild;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.JSXSpreadChild;
    }
    export interface JSXOpeningElementBuilder {
        (name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind, attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[], selfClosing?: boolean): namedTypes.JSXOpeningElement;
        from(params: {
            attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
            selfClosing?: boolean;
        }): namedTypes.JSXOpeningElement;
    }
    export interface JSXClosingElementBuilder {
        (name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind): namedTypes.JSXClosingElement;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
        }): namedTypes.JSXClosingElement;
    }
    export interface JSXOpeningFragmentBuilder {
        (): namedTypes.JSXOpeningFragment;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.JSXOpeningFragment;
    }
    export interface JSXClosingFragmentBuilder {
        (): namedTypes.JSXClosingFragment;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.JSXClosingFragment;
    }
    export interface DecoratorBuilder {
        (expression: K.ExpressionKind): namedTypes.Decorator;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.Decorator;
    }
    export interface PrivateNameBuilder {
        (id: K.IdentifierKind): namedTypes.PrivateName;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.PrivateName;
    }
    export interface ClassPrivatePropertyBuilder {
        (key: K.PrivateNameKind, value?: K.ExpressionKind | null): namedTypes.ClassPrivateProperty;
        from(params: {
            access?: "public" | "private" | "protected" | undefined;
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            key: K.PrivateNameKind;
            loc?: K.SourceLocationKind | null;
            static?: boolean;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            value?: K.ExpressionKind | null;
            variance?: K.VarianceKind | "plus" | "minus" | null;
        }): namedTypes.ClassPrivateProperty;
    }
    export interface TypeParameterDeclarationBuilder {
        (params: K.TypeParameterKind[]): namedTypes.TypeParameterDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            params: K.TypeParameterKind[];
        }): namedTypes.TypeParameterDeclaration;
    }
    export interface TSTypeParameterDeclarationBuilder {
        (params: K.TSTypeParameterKind[]): namedTypes.TSTypeParameterDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            params: K.TSTypeParameterKind[];
        }): namedTypes.TSTypeParameterDeclaration;
    }
    export interface TypeParameterInstantiationBuilder {
        (params: K.FlowTypeKind[]): namedTypes.TypeParameterInstantiation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            params: K.FlowTypeKind[];
        }): namedTypes.TypeParameterInstantiation;
    }
    export interface TSTypeParameterInstantiationBuilder {
        (params: K.TSTypeKind[]): namedTypes.TSTypeParameterInstantiation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            params: K.TSTypeKind[];
        }): namedTypes.TSTypeParameterInstantiation;
    }
    export interface ClassImplementsBuilder {
        (id: K.IdentifierKind): namedTypes.ClassImplements;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            superClass?: K.ExpressionKind | null;
            typeParameters?: K.TypeParameterInstantiationKind | null;
        }): namedTypes.ClassImplements;
    }
    export interface TSExpressionWithTypeArgumentsBuilder {
        (expression: K.IdentifierKind | K.TSQualifiedNameKind, typeParameters?: K.TSTypeParameterInstantiationKind | null): namedTypes.TSExpressionWithTypeArguments;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.IdentifierKind | K.TSQualifiedNameKind;
            loc?: K.SourceLocationKind | null;
            typeParameters?: K.TSTypeParameterInstantiationKind | null;
        }): namedTypes.TSExpressionWithTypeArguments;
    }
    export interface AnyTypeAnnotationBuilder {
        (): namedTypes.AnyTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.AnyTypeAnnotation;
    }
    export interface EmptyTypeAnnotationBuilder {
        (): namedTypes.EmptyTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.EmptyTypeAnnotation;
    }
    export interface MixedTypeAnnotationBuilder {
        (): namedTypes.MixedTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.MixedTypeAnnotation;
    }
    export interface VoidTypeAnnotationBuilder {
        (): namedTypes.VoidTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.VoidTypeAnnotation;
    }
    export interface SymbolTypeAnnotationBuilder {
        (): namedTypes.SymbolTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.SymbolTypeAnnotation;
    }
    export interface NumberTypeAnnotationBuilder {
        (): namedTypes.NumberTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.NumberTypeAnnotation;
    }
    export interface BigIntTypeAnnotationBuilder {
        (): namedTypes.BigIntTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.BigIntTypeAnnotation;
    }
    export interface NumberLiteralTypeAnnotationBuilder {
        (value: number, raw: string): namedTypes.NumberLiteralTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            raw: string;
            value: number;
        }): namedTypes.NumberLiteralTypeAnnotation;
    }
    export interface NumericLiteralTypeAnnotationBuilder {
        (value: number, raw: string): namedTypes.NumericLiteralTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            raw: string;
            value: number;
        }): namedTypes.NumericLiteralTypeAnnotation;
    }
    export interface BigIntLiteralTypeAnnotationBuilder {
        (value: null, raw: string): namedTypes.BigIntLiteralTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            raw: string;
            value: null;
        }): namedTypes.BigIntLiteralTypeAnnotation;
    }
    export interface StringTypeAnnotationBuilder {
        (): namedTypes.StringTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.StringTypeAnnotation;
    }
    export interface StringLiteralTypeAnnotationBuilder {
        (value: string, raw: string): namedTypes.StringLiteralTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            raw: string;
            value: string;
        }): namedTypes.StringLiteralTypeAnnotation;
    }
    export interface BooleanTypeAnnotationBuilder {
        (): namedTypes.BooleanTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.BooleanTypeAnnotation;
    }
    export interface BooleanLiteralTypeAnnotationBuilder {
        (value: boolean, raw: string): namedTypes.BooleanLiteralTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            raw: string;
            value: boolean;
        }): namedTypes.BooleanLiteralTypeAnnotation;
    }
    export interface NullableTypeAnnotationBuilder {
        (typeAnnotation: K.FlowTypeKind): namedTypes.NullableTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.FlowTypeKind;
        }): namedTypes.NullableTypeAnnotation;
    }
    export interface NullLiteralTypeAnnotationBuilder {
        (): namedTypes.NullLiteralTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.NullLiteralTypeAnnotation;
    }
    export interface NullTypeAnnotationBuilder {
        (): namedTypes.NullTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.NullTypeAnnotation;
    }
    export interface ThisTypeAnnotationBuilder {
        (): namedTypes.ThisTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ThisTypeAnnotation;
    }
    export interface ExistsTypeAnnotationBuilder {
        (): namedTypes.ExistsTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ExistsTypeAnnotation;
    }
    export interface ExistentialTypeParamBuilder {
        (): namedTypes.ExistentialTypeParam;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ExistentialTypeParam;
    }
    export interface FunctionTypeAnnotationBuilder {
        (params: K.FunctionTypeParamKind[], returnType: K.FlowTypeKind, rest: K.FunctionTypeParamKind | null, typeParameters: K.TypeParameterDeclarationKind | null): namedTypes.FunctionTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            params: K.FunctionTypeParamKind[];
            rest: K.FunctionTypeParamKind | null;
            returnType: K.FlowTypeKind;
            typeParameters: K.TypeParameterDeclarationKind | null;
        }): namedTypes.FunctionTypeAnnotation;
    }
    export interface FunctionTypeParamBuilder {
        (name: K.IdentifierKind | null, typeAnnotation: K.FlowTypeKind, optional: boolean): namedTypes.FunctionTypeParam;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            name: K.IdentifierKind | null;
            optional: boolean;
            typeAnnotation: K.FlowTypeKind;
        }): namedTypes.FunctionTypeParam;
    }
    export interface ArrayTypeAnnotationBuilder {
        (elementType: K.FlowTypeKind): namedTypes.ArrayTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            elementType: K.FlowTypeKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ArrayTypeAnnotation;
    }
    export interface ObjectTypeAnnotationBuilder {
        (properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[], indexers?: K.ObjectTypeIndexerKind[], callProperties?: K.ObjectTypeCallPropertyKind[]): namedTypes.ObjectTypeAnnotation;
        from(params: {
            callProperties?: K.ObjectTypeCallPropertyKind[];
            comments?: K.CommentKind[] | null;
            exact?: boolean;
            indexers?: K.ObjectTypeIndexerKind[];
            inexact?: boolean | undefined;
            internalSlots?: K.ObjectTypeInternalSlotKind[];
            loc?: K.SourceLocationKind | null;
            properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[];
        }): namedTypes.ObjectTypeAnnotation;
    }
    export interface ObjectTypePropertyBuilder {
        (key: K.LiteralKind | K.IdentifierKind, value: K.FlowTypeKind, optional: boolean): namedTypes.ObjectTypeProperty;
        from(params: {
            comments?: K.CommentKind[] | null;
            key: K.LiteralKind | K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            optional: boolean;
            value: K.FlowTypeKind;
            variance?: K.VarianceKind | "plus" | "minus" | null;
        }): namedTypes.ObjectTypeProperty;
    }
    export interface ObjectTypeSpreadPropertyBuilder {
        (argument: K.FlowTypeKind): namedTypes.ObjectTypeSpreadProperty;
        from(params: {
            argument: K.FlowTypeKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ObjectTypeSpreadProperty;
    }
    export interface ObjectTypeIndexerBuilder {
        (id: K.IdentifierKind, key: K.FlowTypeKind, value: K.FlowTypeKind): namedTypes.ObjectTypeIndexer;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            key: K.FlowTypeKind;
            loc?: K.SourceLocationKind | null;
            static?: boolean;
            value: K.FlowTypeKind;
            variance?: K.VarianceKind | "plus" | "minus" | null;
        }): namedTypes.ObjectTypeIndexer;
    }
    export interface ObjectTypeCallPropertyBuilder {
        (value: K.FunctionTypeAnnotationKind): namedTypes.ObjectTypeCallProperty;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            static?: boolean;
            value: K.FunctionTypeAnnotationKind;
        }): namedTypes.ObjectTypeCallProperty;
    }
    export interface ObjectTypeInternalSlotBuilder {
        (id: K.IdentifierKind, value: K.FlowTypeKind, optional: boolean, staticParam: boolean, method: boolean): namedTypes.ObjectTypeInternalSlot;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            method: boolean;
            optional: boolean;
            static: boolean;
            value: K.FlowTypeKind;
        }): namedTypes.ObjectTypeInternalSlot;
    }
    export interface VarianceBuilder {
        (kind: "plus" | "minus"): namedTypes.Variance;
        from(params: {
            comments?: K.CommentKind[] | null;
            kind: "plus" | "minus";
            loc?: K.SourceLocationKind | null;
        }): namedTypes.Variance;
    }
    export interface QualifiedTypeIdentifierBuilder {
        (qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind, id: K.IdentifierKind): namedTypes.QualifiedTypeIdentifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
        }): namedTypes.QualifiedTypeIdentifier;
    }
    export interface GenericTypeAnnotationBuilder {
        (id: K.IdentifierKind | K.QualifiedTypeIdentifierKind, typeParameters: K.TypeParameterInstantiationKind | null): namedTypes.GenericTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
            loc?: K.SourceLocationKind | null;
            typeParameters: K.TypeParameterInstantiationKind | null;
        }): namedTypes.GenericTypeAnnotation;
    }
    export interface MemberTypeAnnotationBuilder {
        (object: K.IdentifierKind, property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind): namedTypes.MemberTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            object: K.IdentifierKind;
            property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind;
        }): namedTypes.MemberTypeAnnotation;
    }
    export interface UnionTypeAnnotationBuilder {
        (types: K.FlowTypeKind[]): namedTypes.UnionTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            types: K.FlowTypeKind[];
        }): namedTypes.UnionTypeAnnotation;
    }
    export interface IntersectionTypeAnnotationBuilder {
        (types: K.FlowTypeKind[]): namedTypes.IntersectionTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            types: K.FlowTypeKind[];
        }): namedTypes.IntersectionTypeAnnotation;
    }
    export interface TypeofTypeAnnotationBuilder {
        (argument: K.FlowTypeKind): namedTypes.TypeofTypeAnnotation;
        from(params: {
            argument: K.FlowTypeKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TypeofTypeAnnotation;
    }
    export interface TypeParameterBuilder {
        (name: string, variance?: K.VarianceKind | "plus" | "minus" | null, bound?: K.TypeAnnotationKind | null, defaultParam?: K.FlowTypeKind | null): namedTypes.TypeParameter;
        from(params: {
            bound?: K.TypeAnnotationKind | null;
            comments?: K.CommentKind[] | null;
            default?: K.FlowTypeKind | null;
            loc?: K.SourceLocationKind | null;
            name: string;
            variance?: K.VarianceKind | "plus" | "minus" | null;
        }): namedTypes.TypeParameter;
    }
    export interface InterfaceTypeAnnotationBuilder {
        (body: K.ObjectTypeAnnotationKind, extendsParam?: K.InterfaceExtendsKind[] | null): namedTypes.InterfaceTypeAnnotation;
        from(params: {
            body: K.ObjectTypeAnnotationKind;
            comments?: K.CommentKind[] | null;
            extends?: K.InterfaceExtendsKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.InterfaceTypeAnnotation;
    }
    export interface InterfaceExtendsBuilder {
        (id: K.IdentifierKind): namedTypes.InterfaceExtends;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            typeParameters?: K.TypeParameterInstantiationKind | null;
        }): namedTypes.InterfaceExtends;
    }
    export interface InterfaceDeclarationBuilder {
        (id: K.IdentifierKind, body: K.ObjectTypeAnnotationKind, extendsParam: K.InterfaceExtendsKind[]): namedTypes.InterfaceDeclaration;
        from(params: {
            body: K.ObjectTypeAnnotationKind;
            comments?: K.CommentKind[] | null;
            extends: K.InterfaceExtendsKind[];
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | null;
        }): namedTypes.InterfaceDeclaration;
    }
    export interface DeclareInterfaceBuilder {
        (id: K.IdentifierKind, body: K.ObjectTypeAnnotationKind, extendsParam: K.InterfaceExtendsKind[]): namedTypes.DeclareInterface;
        from(params: {
            body: K.ObjectTypeAnnotationKind;
            comments?: K.CommentKind[] | null;
            extends: K.InterfaceExtendsKind[];
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | null;
        }): namedTypes.DeclareInterface;
    }
    export interface TypeAliasBuilder {
        (id: K.IdentifierKind, typeParameters: K.TypeParameterDeclarationKind | null, right: K.FlowTypeKind): namedTypes.TypeAlias;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            right: K.FlowTypeKind;
            typeParameters: K.TypeParameterDeclarationKind | null;
        }): namedTypes.TypeAlias;
    }
    export interface DeclareTypeAliasBuilder {
        (id: K.IdentifierKind, typeParameters: K.TypeParameterDeclarationKind | null, right: K.FlowTypeKind): namedTypes.DeclareTypeAlias;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            right: K.FlowTypeKind;
            typeParameters: K.TypeParameterDeclarationKind | null;
        }): namedTypes.DeclareTypeAlias;
    }
    export interface OpaqueTypeBuilder {
        (id: K.IdentifierKind, typeParameters: K.TypeParameterDeclarationKind | null, impltype: K.FlowTypeKind, supertype: K.FlowTypeKind | null): namedTypes.OpaqueType;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            impltype: K.FlowTypeKind;
            loc?: K.SourceLocationKind | null;
            supertype: K.FlowTypeKind | null;
            typeParameters: K.TypeParameterDeclarationKind | null;
        }): namedTypes.OpaqueType;
    }
    export interface DeclareOpaqueTypeBuilder {
        (id: K.IdentifierKind, typeParameters: K.TypeParameterDeclarationKind | null, supertype: K.FlowTypeKind | null): namedTypes.DeclareOpaqueType;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            impltype: K.FlowTypeKind | null;
            loc?: K.SourceLocationKind | null;
            supertype: K.FlowTypeKind | null;
            typeParameters: K.TypeParameterDeclarationKind | null;
        }): namedTypes.DeclareOpaqueType;
    }
    export interface TypeCastExpressionBuilder {
        (expression: K.ExpressionKind, typeAnnotation: K.TypeAnnotationKind): namedTypes.TypeCastExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TypeAnnotationKind;
        }): namedTypes.TypeCastExpression;
    }
    export interface TupleTypeAnnotationBuilder {
        (types: K.FlowTypeKind[]): namedTypes.TupleTypeAnnotation;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            types: K.FlowTypeKind[];
        }): namedTypes.TupleTypeAnnotation;
    }
    export interface DeclareVariableBuilder {
        (id: K.IdentifierKind): namedTypes.DeclareVariable;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.DeclareVariable;
    }
    export interface DeclareFunctionBuilder {
        (id: K.IdentifierKind): namedTypes.DeclareFunction;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            predicate?: K.FlowPredicateKind | null;
        }): namedTypes.DeclareFunction;
    }
    export interface DeclareClassBuilder {
        (id: K.IdentifierKind): namedTypes.DeclareClass;
        from(params: {
            body: K.ObjectTypeAnnotationKind;
            comments?: K.CommentKind[] | null;
            extends: K.InterfaceExtendsKind[];
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | null;
        }): namedTypes.DeclareClass;
    }
    export interface DeclareModuleBuilder {
        (id: K.IdentifierKind | K.LiteralKind, body: K.BlockStatementKind): namedTypes.DeclareModule;
        from(params: {
            body: K.BlockStatementKind;
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind | K.LiteralKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.DeclareModule;
    }
    export interface DeclareModuleExportsBuilder {
        (typeAnnotation: K.TypeAnnotationKind): namedTypes.DeclareModuleExports;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TypeAnnotationKind;
        }): namedTypes.DeclareModuleExports;
    }
    export interface DeclareExportDeclarationBuilder {
        (defaultParam: boolean, declaration: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | K.TypeAliasKind | K.DeclareOpaqueTypeKind | K.InterfaceDeclarationKind | null, specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[], source?: K.LiteralKind | null): namedTypes.DeclareExportDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            declaration: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | K.TypeAliasKind | K.DeclareOpaqueTypeKind | K.InterfaceDeclarationKind | null;
            default: boolean;
            loc?: K.SourceLocationKind | null;
            source?: K.LiteralKind | null;
            specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
        }): namedTypes.DeclareExportDeclaration;
    }
    export interface ExportBatchSpecifierBuilder {
        (): namedTypes.ExportBatchSpecifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ExportBatchSpecifier;
    }
    export interface DeclareExportAllDeclarationBuilder {
        (source?: K.LiteralKind | null): namedTypes.DeclareExportAllDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            source?: K.LiteralKind | null;
        }): namedTypes.DeclareExportAllDeclaration;
    }
    export interface InferredPredicateBuilder {
        (): namedTypes.InferredPredicate;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.InferredPredicate;
    }
    export interface DeclaredPredicateBuilder {
        (value: K.ExpressionKind): namedTypes.DeclaredPredicate;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            value: K.ExpressionKind;
        }): namedTypes.DeclaredPredicate;
    }
    export interface EnumDeclarationBuilder {
        (id: K.IdentifierKind, body: K.EnumBooleanBodyKind | K.EnumNumberBodyKind | K.EnumStringBodyKind | K.EnumSymbolBodyKind): namedTypes.EnumDeclaration;
        from(params: {
            body: K.EnumBooleanBodyKind | K.EnumNumberBodyKind | K.EnumStringBodyKind | K.EnumSymbolBodyKind;
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.EnumDeclaration;
    }
    export interface EnumBooleanBodyBuilder {
        (members: K.EnumBooleanMemberKind[], explicitType: boolean): namedTypes.EnumBooleanBody;
        from(params: {
            explicitType: boolean;
            members: K.EnumBooleanMemberKind[];
        }): namedTypes.EnumBooleanBody;
    }
    export interface EnumNumberBodyBuilder {
        (members: K.EnumNumberMemberKind[], explicitType: boolean): namedTypes.EnumNumberBody;
        from(params: {
            explicitType: boolean;
            members: K.EnumNumberMemberKind[];
        }): namedTypes.EnumNumberBody;
    }
    export interface EnumStringBodyBuilder {
        (members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[], explicitType: boolean): namedTypes.EnumStringBody;
        from(params: {
            explicitType: boolean;
            members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[];
        }): namedTypes.EnumStringBody;
    }
    export interface EnumSymbolBodyBuilder {
        (members: K.EnumDefaultedMemberKind[]): namedTypes.EnumSymbolBody;
        from(params: {
            members: K.EnumDefaultedMemberKind[];
        }): namedTypes.EnumSymbolBody;
    }
    export interface EnumBooleanMemberBuilder {
        (id: K.IdentifierKind, init: K.LiteralKind | boolean): namedTypes.EnumBooleanMember;
        from(params: {
            id: K.IdentifierKind;
            init: K.LiteralKind | boolean;
        }): namedTypes.EnumBooleanMember;
    }
    export interface EnumNumberMemberBuilder {
        (id: K.IdentifierKind, init: K.LiteralKind): namedTypes.EnumNumberMember;
        from(params: {
            id: K.IdentifierKind;
            init: K.LiteralKind;
        }): namedTypes.EnumNumberMember;
    }
    export interface EnumStringMemberBuilder {
        (id: K.IdentifierKind, init: K.LiteralKind): namedTypes.EnumStringMember;
        from(params: {
            id: K.IdentifierKind;
            init: K.LiteralKind;
        }): namedTypes.EnumStringMember;
    }
    export interface EnumDefaultedMemberBuilder {
        (id: K.IdentifierKind): namedTypes.EnumDefaultedMember;
        from(params: {
            id: K.IdentifierKind;
        }): namedTypes.EnumDefaultedMember;
    }
    export interface ExportDeclarationBuilder {
        (defaultParam: boolean, declaration: K.DeclarationKind | K.ExpressionKind | null, specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[], source?: K.LiteralKind | null): namedTypes.ExportDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            declaration: K.DeclarationKind | K.ExpressionKind | null;
            default: boolean;
            loc?: K.SourceLocationKind | null;
            source?: K.LiteralKind | null;
            specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
        }): namedTypes.ExportDeclaration;
    }
    export interface BlockBuilder {
        (value: string, leading?: boolean, trailing?: boolean): namedTypes.Block;
        from(params: {
            leading?: boolean;
            loc?: K.SourceLocationKind | null;
            trailing?: boolean;
            value: string;
        }): namedTypes.Block;
    }
    export interface LineBuilder {
        (value: string, leading?: boolean, trailing?: boolean): namedTypes.Line;
        from(params: {
            leading?: boolean;
            loc?: K.SourceLocationKind | null;
            trailing?: boolean;
            value: string;
        }): namedTypes.Line;
    }
    export interface NoopBuilder {
        (): namedTypes.Noop;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.Noop;
    }
    export interface DoExpressionBuilder {
        (body: K.StatementKind[]): namedTypes.DoExpression;
        from(params: {
            body: K.StatementKind[];
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.DoExpression;
    }
    export interface BindExpressionBuilder {
        (object: K.ExpressionKind | null, callee: K.ExpressionKind): namedTypes.BindExpression;
        from(params: {
            callee: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            object: K.ExpressionKind | null;
        }): namedTypes.BindExpression;
    }
    export interface ParenthesizedExpressionBuilder {
        (expression: K.ExpressionKind): namedTypes.ParenthesizedExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ParenthesizedExpression;
    }
    export interface ExportNamespaceSpecifierBuilder {
        (exported: K.IdentifierKind): namedTypes.ExportNamespaceSpecifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            exported: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ExportNamespaceSpecifier;
    }
    export interface ExportDefaultSpecifierBuilder {
        (exported: K.IdentifierKind): namedTypes.ExportDefaultSpecifier;
        from(params: {
            comments?: K.CommentKind[] | null;
            exported: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.ExportDefaultSpecifier;
    }
    export interface CommentBlockBuilder {
        (value: string, leading?: boolean, trailing?: boolean): namedTypes.CommentBlock;
        from(params: {
            leading?: boolean;
            loc?: K.SourceLocationKind | null;
            trailing?: boolean;
            value: string;
        }): namedTypes.CommentBlock;
    }
    export interface CommentLineBuilder {
        (value: string, leading?: boolean, trailing?: boolean): namedTypes.CommentLine;
        from(params: {
            leading?: boolean;
            loc?: K.SourceLocationKind | null;
            trailing?: boolean;
            value: string;
        }): namedTypes.CommentLine;
    }
    export interface DirectiveBuilder {
        (value: K.DirectiveLiteralKind): namedTypes.Directive;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            value: K.DirectiveLiteralKind;
        }): namedTypes.Directive;
    }
    export interface DirectiveLiteralBuilder {
        (value?: string): namedTypes.DirectiveLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            value?: string;
        }): namedTypes.DirectiveLiteral;
    }
    export interface InterpreterDirectiveBuilder {
        (value: string): namedTypes.InterpreterDirective;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            value: string;
        }): namedTypes.InterpreterDirective;
    }
    export interface StringLiteralBuilder {
        (value: string): namedTypes.StringLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
            value: string;
        }): namedTypes.StringLiteral;
    }
    export interface NumericLiteralBuilder {
        (value: number): namedTypes.NumericLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            extra?: {
                rawValue: number;
                raw: string;
            };
            loc?: K.SourceLocationKind | null;
            raw?: string | null;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
            value: number;
        }): namedTypes.NumericLiteral;
    }
    export interface BigIntLiteralBuilder {
        (value: string | number): namedTypes.BigIntLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            extra?: {
                rawValue: string;
                raw: string;
            };
            loc?: K.SourceLocationKind | null;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
            value: string | number;
        }): namedTypes.BigIntLiteral;
    }
    export interface NullLiteralBuilder {
        (): namedTypes.NullLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
            value?: null;
        }): namedTypes.NullLiteral;
    }
    export interface BooleanLiteralBuilder {
        (value: boolean): namedTypes.BooleanLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
            value: boolean;
        }): namedTypes.BooleanLiteral;
    }
    export interface RegExpLiteralBuilder {
        (pattern: string, flags: string): namedTypes.RegExpLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            flags: string;
            loc?: K.SourceLocationKind | null;
            pattern: string;
            regex?: {
                pattern: string;
                flags: string;
            } | null;
            value?: RegExp;
        }): namedTypes.RegExpLiteral;
    }
    export interface ObjectMethodBuilder {
        (kind: "method" | "get" | "set", key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, params: K.PatternKind[], body: K.BlockStatementKind, computed?: boolean): namedTypes.ObjectMethod;
        from(params: {
            accessibility?: K.LiteralKind | null;
            async?: boolean;
            body: K.BlockStatementKind;
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            decorators?: K.DecoratorKind[] | null;
            defaults?: (K.ExpressionKind | null)[];
            expression?: boolean;
            generator?: boolean;
            id?: K.IdentifierKind | null;
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            kind: "method" | "get" | "set";
            loc?: K.SourceLocationKind | null;
            params: K.PatternKind[];
            predicate?: K.FlowPredicateKind | null;
            rest?: K.IdentifierKind | null;
            returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        }): namedTypes.ObjectMethod;
    }
    export interface ClassMethodBuilder {
        (kind: "get" | "set" | "method" | "constructor" | undefined, key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, params: K.PatternKind[], body: K.BlockStatementKind, computed?: boolean, staticParam?: boolean | null): namedTypes.ClassMethod;
        from(params: {
            abstract?: boolean | null;
            access?: "public" | "private" | "protected" | null;
            accessibility?: "public" | "private" | "protected" | null;
            async?: boolean;
            body: K.BlockStatementKind;
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            decorators?: K.DecoratorKind[] | null;
            defaults?: (K.ExpressionKind | null)[];
            expression?: boolean;
            generator?: boolean;
            id?: K.IdentifierKind | null;
            key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
            kind?: "get" | "set" | "method" | "constructor";
            loc?: K.SourceLocationKind | null;
            optional?: boolean | null;
            params: K.PatternKind[];
            predicate?: K.FlowPredicateKind | null;
            rest?: K.IdentifierKind | null;
            returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            static?: boolean | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        }): namedTypes.ClassMethod;
    }
    export interface ClassPrivateMethodBuilder {
        (key: K.PrivateNameKind, params: K.PatternKind[], body: K.BlockStatementKind, kind?: "get" | "set" | "method" | "constructor", computed?: boolean, staticParam?: boolean | null): namedTypes.ClassPrivateMethod;
        from(params: {
            abstract?: boolean | null;
            access?: "public" | "private" | "protected" | null;
            accessibility?: "public" | "private" | "protected" | null;
            async?: boolean;
            body: K.BlockStatementKind;
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            decorators?: K.DecoratorKind[] | null;
            defaults?: (K.ExpressionKind | null)[];
            expression?: boolean;
            generator?: boolean;
            id?: K.IdentifierKind | null;
            key: K.PrivateNameKind;
            kind?: "get" | "set" | "method" | "constructor";
            loc?: K.SourceLocationKind | null;
            optional?: boolean | null;
            params: K.PatternKind[];
            predicate?: K.FlowPredicateKind | null;
            rest?: K.IdentifierKind | null;
            returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
            static?: boolean | null;
            typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        }): namedTypes.ClassPrivateMethod;
    }
    export interface RestPropertyBuilder {
        (argument: K.ExpressionKind): namedTypes.RestProperty;
        from(params: {
            argument: K.ExpressionKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.RestProperty;
    }
    export interface ForAwaitStatementBuilder {
        (left: K.VariableDeclarationKind | K.ExpressionKind, right: K.ExpressionKind, body: K.StatementKind): namedTypes.ForAwaitStatement;
        from(params: {
            body: K.StatementKind;
            comments?: K.CommentKind[] | null;
            left: K.VariableDeclarationKind | K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            right: K.ExpressionKind;
        }): namedTypes.ForAwaitStatement;
    }
    export interface ImportBuilder {
        (): namedTypes.Import;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.Import;
    }
    export interface TSQualifiedNameBuilder {
        (left: K.IdentifierKind | K.TSQualifiedNameKind, right: K.IdentifierKind | K.TSQualifiedNameKind): namedTypes.TSQualifiedName;
        from(params: {
            comments?: K.CommentKind[] | null;
            left: K.IdentifierKind | K.TSQualifiedNameKind;
            loc?: K.SourceLocationKind | null;
            right: K.IdentifierKind | K.TSQualifiedNameKind;
        }): namedTypes.TSQualifiedName;
    }
    export interface TSTypeReferenceBuilder {
        (typeName: K.IdentifierKind | K.TSQualifiedNameKind, typeParameters?: K.TSTypeParameterInstantiationKind | null): namedTypes.TSTypeReference;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeName: K.IdentifierKind | K.TSQualifiedNameKind;
            typeParameters?: K.TSTypeParameterInstantiationKind | null;
        }): namedTypes.TSTypeReference;
    }
    export interface TSAsExpressionBuilder {
        (expression: K.ExpressionKind, typeAnnotation: K.TSTypeKind): namedTypes.TSAsExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            extra?: {
                parenthesized: boolean;
            } | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TSTypeKind;
        }): namedTypes.TSAsExpression;
    }
    export interface TSNonNullExpressionBuilder {
        (expression: K.ExpressionKind): namedTypes.TSNonNullExpression;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSNonNullExpression;
    }
    export interface TSAnyKeywordBuilder {
        (): namedTypes.TSAnyKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSAnyKeyword;
    }
    export interface TSBigIntKeywordBuilder {
        (): namedTypes.TSBigIntKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSBigIntKeyword;
    }
    export interface TSBooleanKeywordBuilder {
        (): namedTypes.TSBooleanKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSBooleanKeyword;
    }
    export interface TSNeverKeywordBuilder {
        (): namedTypes.TSNeverKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSNeverKeyword;
    }
    export interface TSNullKeywordBuilder {
        (): namedTypes.TSNullKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSNullKeyword;
    }
    export interface TSNumberKeywordBuilder {
        (): namedTypes.TSNumberKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSNumberKeyword;
    }
    export interface TSObjectKeywordBuilder {
        (): namedTypes.TSObjectKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSObjectKeyword;
    }
    export interface TSStringKeywordBuilder {
        (): namedTypes.TSStringKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSStringKeyword;
    }
    export interface TSSymbolKeywordBuilder {
        (): namedTypes.TSSymbolKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSSymbolKeyword;
    }
    export interface TSUndefinedKeywordBuilder {
        (): namedTypes.TSUndefinedKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSUndefinedKeyword;
    }
    export interface TSUnknownKeywordBuilder {
        (): namedTypes.TSUnknownKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSUnknownKeyword;
    }
    export interface TSVoidKeywordBuilder {
        (): namedTypes.TSVoidKeyword;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSVoidKeyword;
    }
    export interface TSThisTypeBuilder {
        (): namedTypes.TSThisType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSThisType;
    }
    export interface TSArrayTypeBuilder {
        (elementType: K.TSTypeKind): namedTypes.TSArrayType;
        from(params: {
            comments?: K.CommentKind[] | null;
            elementType: K.TSTypeKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSArrayType;
    }
    export interface TSLiteralTypeBuilder {
        (literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind | K.TemplateLiteralKind | K.UnaryExpressionKind): namedTypes.TSLiteralType;
        from(params: {
            comments?: K.CommentKind[] | null;
            literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind | K.TemplateLiteralKind | K.UnaryExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSLiteralType;
    }
    export interface TSUnionTypeBuilder {
        (types: K.TSTypeKind[]): namedTypes.TSUnionType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            types: K.TSTypeKind[];
        }): namedTypes.TSUnionType;
    }
    export interface TSIntersectionTypeBuilder {
        (types: K.TSTypeKind[]): namedTypes.TSIntersectionType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            types: K.TSTypeKind[];
        }): namedTypes.TSIntersectionType;
    }
    export interface TSConditionalTypeBuilder {
        (checkType: K.TSTypeKind, extendsType: K.TSTypeKind, trueType: K.TSTypeKind, falseType: K.TSTypeKind): namedTypes.TSConditionalType;
        from(params: {
            checkType: K.TSTypeKind;
            comments?: K.CommentKind[] | null;
            extendsType: K.TSTypeKind;
            falseType: K.TSTypeKind;
            loc?: K.SourceLocationKind | null;
            trueType: K.TSTypeKind;
        }): namedTypes.TSConditionalType;
    }
    export interface TSInferTypeBuilder {
        (typeParameter: K.TSTypeParameterKind): namedTypes.TSInferType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeParameter: K.TSTypeParameterKind;
        }): namedTypes.TSInferType;
    }
    export interface TSTypeParameterBuilder {
        (name: string, constraint?: K.TSTypeKind | undefined, defaultParam?: K.TSTypeKind | undefined): namedTypes.TSTypeParameter;
        from(params: {
            comments?: K.CommentKind[] | null;
            constraint?: K.TSTypeKind | undefined;
            default?: K.TSTypeKind | undefined;
            loc?: K.SourceLocationKind | null;
            name: string;
            optional?: boolean;
            typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        }): namedTypes.TSTypeParameter;
    }
    export interface TSParenthesizedTypeBuilder {
        (typeAnnotation: K.TSTypeKind): namedTypes.TSParenthesizedType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TSTypeKind;
        }): namedTypes.TSParenthesizedType;
    }
    export interface TSFunctionTypeBuilder {
        (parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[]): namedTypes.TSFunctionType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
            typeAnnotation?: K.TSTypeAnnotationKind | null;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSFunctionType;
    }
    export interface TSConstructorTypeBuilder {
        (parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[]): namedTypes.TSConstructorType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
            typeAnnotation?: K.TSTypeAnnotationKind | null;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSConstructorType;
    }
    export interface TSDeclareFunctionBuilder {
        (id: K.IdentifierKind | null | undefined, params: K.PatternKind[], returnType?: K.TSTypeAnnotationKind | K.NoopKind | null): namedTypes.TSDeclareFunction;
        from(params: {
            async?: boolean;
            comments?: K.CommentKind[] | null;
            declare?: boolean;
            generator?: boolean;
            id?: K.IdentifierKind | null;
            loc?: K.SourceLocationKind | null;
            params: K.PatternKind[];
            returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSDeclareFunction;
    }
    export interface TSDeclareMethodBuilder {
        (key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind, params: K.PatternKind[], returnType?: K.TSTypeAnnotationKind | K.NoopKind | null): namedTypes.TSDeclareMethod;
        from(params: {
            abstract?: boolean;
            access?: "public" | "private" | "protected" | undefined;
            accessibility?: "public" | "private" | "protected" | undefined;
            async?: boolean;
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            decorators?: K.DecoratorKind[] | null;
            generator?: boolean;
            key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind;
            kind?: "get" | "set" | "method" | "constructor";
            loc?: K.SourceLocationKind | null;
            optional?: boolean;
            params: K.PatternKind[];
            returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
            static?: boolean;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSDeclareMethod;
    }
    export interface TSMappedTypeBuilder {
        (typeParameter: K.TSTypeParameterKind, typeAnnotation?: K.TSTypeKind | null): namedTypes.TSMappedType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            optional?: boolean | "+" | "-";
            readonly?: boolean | "+" | "-";
            typeAnnotation?: K.TSTypeKind | null;
            typeParameter: K.TSTypeParameterKind;
        }): namedTypes.TSMappedType;
    }
    export interface TSTupleTypeBuilder {
        (elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[]): namedTypes.TSTupleType;
        from(params: {
            comments?: K.CommentKind[] | null;
            elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[];
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSTupleType;
    }
    export interface TSNamedTupleMemberBuilder {
        (label: K.IdentifierKind, elementType: K.TSTypeKind, optional?: boolean): namedTypes.TSNamedTupleMember;
        from(params: {
            comments?: K.CommentKind[] | null;
            elementType: K.TSTypeKind;
            label: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            optional?: boolean;
        }): namedTypes.TSNamedTupleMember;
    }
    export interface TSRestTypeBuilder {
        (typeAnnotation: K.TSTypeKind): namedTypes.TSRestType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TSTypeKind;
        }): namedTypes.TSRestType;
    }
    export interface TSOptionalTypeBuilder {
        (typeAnnotation: K.TSTypeKind): namedTypes.TSOptionalType;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TSTypeKind;
        }): namedTypes.TSOptionalType;
    }
    export interface TSIndexedAccessTypeBuilder {
        (objectType: K.TSTypeKind, indexType: K.TSTypeKind): namedTypes.TSIndexedAccessType;
        from(params: {
            comments?: K.CommentKind[] | null;
            indexType: K.TSTypeKind;
            loc?: K.SourceLocationKind | null;
            objectType: K.TSTypeKind;
        }): namedTypes.TSIndexedAccessType;
    }
    export interface TSTypeOperatorBuilder {
        (operator: string): namedTypes.TSTypeOperator;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            operator: string;
            typeAnnotation: K.TSTypeKind;
        }): namedTypes.TSTypeOperator;
    }
    export interface TSIndexSignatureBuilder {
        (parameters: K.IdentifierKind[], typeAnnotation?: K.TSTypeAnnotationKind | null): namedTypes.TSIndexSignature;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            parameters: K.IdentifierKind[];
            readonly?: boolean;
            typeAnnotation?: K.TSTypeAnnotationKind | null;
        }): namedTypes.TSIndexSignature;
    }
    export interface TSPropertySignatureBuilder {
        (key: K.ExpressionKind, typeAnnotation?: K.TSTypeAnnotationKind | null, optional?: boolean): namedTypes.TSPropertySignature;
        from(params: {
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            initializer?: K.ExpressionKind | null;
            key: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            optional?: boolean;
            readonly?: boolean;
            typeAnnotation?: K.TSTypeAnnotationKind | null;
        }): namedTypes.TSPropertySignature;
    }
    export interface TSMethodSignatureBuilder {
        (key: K.ExpressionKind, parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[], typeAnnotation?: K.TSTypeAnnotationKind | null): namedTypes.TSMethodSignature;
        from(params: {
            comments?: K.CommentKind[] | null;
            computed?: boolean;
            key: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
            optional?: boolean;
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
            typeAnnotation?: K.TSTypeAnnotationKind | null;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSMethodSignature;
    }
    export interface TSTypePredicateBuilder {
        (parameterName: K.IdentifierKind | K.TSThisTypeKind, typeAnnotation?: K.TSTypeAnnotationKind | null, asserts?: boolean): namedTypes.TSTypePredicate;
        from(params: {
            asserts?: boolean;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            parameterName: K.IdentifierKind | K.TSThisTypeKind;
            typeAnnotation?: K.TSTypeAnnotationKind | null;
        }): namedTypes.TSTypePredicate;
    }
    export interface TSCallSignatureDeclarationBuilder {
        (parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[], typeAnnotation?: K.TSTypeAnnotationKind | null): namedTypes.TSCallSignatureDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
            typeAnnotation?: K.TSTypeAnnotationKind | null;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSCallSignatureDeclaration;
    }
    export interface TSConstructSignatureDeclarationBuilder {
        (parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[], typeAnnotation?: K.TSTypeAnnotationKind | null): namedTypes.TSConstructSignatureDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
            typeAnnotation?: K.TSTypeAnnotationKind | null;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSConstructSignatureDeclaration;
    }
    export interface TSEnumMemberBuilder {
        (id: K.IdentifierKind | K.StringLiteralKind, initializer?: K.ExpressionKind | null): namedTypes.TSEnumMember;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind | K.StringLiteralKind;
            initializer?: K.ExpressionKind | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSEnumMember;
    }
    export interface TSTypeQueryBuilder {
        (exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind): namedTypes.TSTypeQuery;
        from(params: {
            comments?: K.CommentKind[] | null;
            exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSTypeQuery;
    }
    export interface TSImportTypeBuilder {
        (argument: K.StringLiteralKind, qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined, typeParameters?: K.TSTypeParameterInstantiationKind | null): namedTypes.TSImportType;
        from(params: {
            argument: K.StringLiteralKind;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined;
            typeParameters?: K.TSTypeParameterInstantiationKind | null;
        }): namedTypes.TSImportType;
    }
    export interface TSTypeLiteralBuilder {
        (members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]): namedTypes.TSTypeLiteral;
        from(params: {
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
        }): namedTypes.TSTypeLiteral;
    }
    export interface TSTypeAssertionBuilder {
        (typeAnnotation: K.TSTypeKind, expression: K.ExpressionKind): namedTypes.TSTypeAssertion;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            extra?: {
                parenthesized: boolean;
            } | null;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TSTypeKind;
        }): namedTypes.TSTypeAssertion;
    }
    export interface TSEnumDeclarationBuilder {
        (id: K.IdentifierKind, members: K.TSEnumMemberKind[]): namedTypes.TSEnumDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            const?: boolean;
            declare?: boolean;
            id: K.IdentifierKind;
            initializer?: K.ExpressionKind | null;
            loc?: K.SourceLocationKind | null;
            members: K.TSEnumMemberKind[];
        }): namedTypes.TSEnumDeclaration;
    }
    export interface TSTypeAliasDeclarationBuilder {
        (id: K.IdentifierKind, typeAnnotation: K.TSTypeKind): namedTypes.TSTypeAliasDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            declare?: boolean;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
            typeAnnotation: K.TSTypeKind;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSTypeAliasDeclaration;
    }
    export interface TSModuleBlockBuilder {
        (body: K.StatementKind[]): namedTypes.TSModuleBlock;
        from(params: {
            body: K.StatementKind[];
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSModuleBlock;
    }
    export interface TSModuleDeclarationBuilder {
        (id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind, body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null): namedTypes.TSModuleDeclaration;
        from(params: {
            body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null;
            comments?: K.CommentKind[] | null;
            declare?: boolean;
            global?: boolean;
            id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSModuleDeclaration;
    }
    export interface TSImportEqualsDeclarationBuilder {
        (id: K.IdentifierKind, moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind): namedTypes.TSImportEqualsDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            isExport?: boolean;
            loc?: K.SourceLocationKind | null;
            moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind;
        }): namedTypes.TSImportEqualsDeclaration;
    }
    export interface TSExternalModuleReferenceBuilder {
        (expression: K.StringLiteralKind): namedTypes.TSExternalModuleReference;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.StringLiteralKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSExternalModuleReference;
    }
    export interface TSExportAssignmentBuilder {
        (expression: K.ExpressionKind): namedTypes.TSExportAssignment;
        from(params: {
            comments?: K.CommentKind[] | null;
            expression: K.ExpressionKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSExportAssignment;
    }
    export interface TSNamespaceExportDeclarationBuilder {
        (id: K.IdentifierKind): namedTypes.TSNamespaceExportDeclaration;
        from(params: {
            comments?: K.CommentKind[] | null;
            id: K.IdentifierKind;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSNamespaceExportDeclaration;
    }
    export interface TSInterfaceBodyBuilder {
        (body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]): namedTypes.TSInterfaceBody;
        from(params: {
            body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
        }): namedTypes.TSInterfaceBody;
    }
    export interface TSInterfaceDeclarationBuilder {
        (id: K.IdentifierKind | K.TSQualifiedNameKind, body: K.TSInterfaceBodyKind): namedTypes.TSInterfaceDeclaration;
        from(params: {
            body: K.TSInterfaceBodyKind;
            comments?: K.CommentKind[] | null;
            declare?: boolean;
            extends?: K.TSExpressionWithTypeArgumentsKind[] | null;
            id: K.IdentifierKind | K.TSQualifiedNameKind;
            loc?: K.SourceLocationKind | null;
            typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
        }): namedTypes.TSInterfaceDeclaration;
    }
    export interface TSParameterPropertyBuilder {
        (parameter: K.IdentifierKind | K.AssignmentPatternKind): namedTypes.TSParameterProperty;
        from(params: {
            accessibility?: "public" | "private" | "protected" | undefined;
            comments?: K.CommentKind[] | null;
            loc?: K.SourceLocationKind | null;
            parameter: K.IdentifierKind | K.AssignmentPatternKind;
            readonly?: boolean;
        }): namedTypes.TSParameterProperty;
    }
    export interface builders {
        file: FileBuilder;
        program: ProgramBuilder;
        identifier: IdentifierBuilder;
        blockStatement: BlockStatementBuilder;
        emptyStatement: EmptyStatementBuilder;
        expressionStatement: ExpressionStatementBuilder;
        ifStatement: IfStatementBuilder;
        labeledStatement: LabeledStatementBuilder;
        breakStatement: BreakStatementBuilder;
        continueStatement: ContinueStatementBuilder;
        withStatement: WithStatementBuilder;
        switchStatement: SwitchStatementBuilder;
        switchCase: SwitchCaseBuilder;
        returnStatement: ReturnStatementBuilder;
        throwStatement: ThrowStatementBuilder;
        tryStatement: TryStatementBuilder;
        catchClause: CatchClauseBuilder;
        whileStatement: WhileStatementBuilder;
        doWhileStatement: DoWhileStatementBuilder;
        forStatement: ForStatementBuilder;
        variableDeclaration: VariableDeclarationBuilder;
        forInStatement: ForInStatementBuilder;
        debuggerStatement: DebuggerStatementBuilder;
        functionDeclaration: FunctionDeclarationBuilder;
        functionExpression: FunctionExpressionBuilder;
        variableDeclarator: VariableDeclaratorBuilder;
        thisExpression: ThisExpressionBuilder;
        arrayExpression: ArrayExpressionBuilder;
        objectExpression: ObjectExpressionBuilder;
        property: PropertyBuilder;
        literal: LiteralBuilder;
        sequenceExpression: SequenceExpressionBuilder;
        unaryExpression: UnaryExpressionBuilder;
        binaryExpression: BinaryExpressionBuilder;
        assignmentExpression: AssignmentExpressionBuilder;
        memberExpression: MemberExpressionBuilder;
        updateExpression: UpdateExpressionBuilder;
        logicalExpression: LogicalExpressionBuilder;
        conditionalExpression: ConditionalExpressionBuilder;
        newExpression: NewExpressionBuilder;
        callExpression: CallExpressionBuilder;
        restElement: RestElementBuilder;
        typeAnnotation: TypeAnnotationBuilder;
        tsTypeAnnotation: TSTypeAnnotationBuilder;
        spreadElementPattern: SpreadElementPatternBuilder;
        arrowFunctionExpression: ArrowFunctionExpressionBuilder;
        forOfStatement: ForOfStatementBuilder;
        yieldExpression: YieldExpressionBuilder;
        generatorExpression: GeneratorExpressionBuilder;
        comprehensionBlock: ComprehensionBlockBuilder;
        comprehensionExpression: ComprehensionExpressionBuilder;
        objectProperty: ObjectPropertyBuilder;
        propertyPattern: PropertyPatternBuilder;
        objectPattern: ObjectPatternBuilder;
        arrayPattern: ArrayPatternBuilder;
        spreadElement: SpreadElementBuilder;
        assignmentPattern: AssignmentPatternBuilder;
        methodDefinition: MethodDefinitionBuilder;
        classPropertyDefinition: ClassPropertyDefinitionBuilder;
        classProperty: ClassPropertyBuilder;
        classBody: ClassBodyBuilder;
        classDeclaration: ClassDeclarationBuilder;
        classExpression: ClassExpressionBuilder;
        super: SuperBuilder;
        importSpecifier: ImportSpecifierBuilder;
        importDefaultSpecifier: ImportDefaultSpecifierBuilder;
        importNamespaceSpecifier: ImportNamespaceSpecifierBuilder;
        importDeclaration: ImportDeclarationBuilder;
        exportNamedDeclaration: ExportNamedDeclarationBuilder;
        exportSpecifier: ExportSpecifierBuilder;
        exportDefaultDeclaration: ExportDefaultDeclarationBuilder;
        exportAllDeclaration: ExportAllDeclarationBuilder;
        taggedTemplateExpression: TaggedTemplateExpressionBuilder;
        templateLiteral: TemplateLiteralBuilder;
        templateElement: TemplateElementBuilder;
        metaProperty: MetaPropertyBuilder;
        awaitExpression: AwaitExpressionBuilder;
        spreadProperty: SpreadPropertyBuilder;
        spreadPropertyPattern: SpreadPropertyPatternBuilder;
        importExpression: ImportExpressionBuilder;
        chainExpression: ChainExpressionBuilder;
        optionalCallExpression: OptionalCallExpressionBuilder;
        optionalMemberExpression: OptionalMemberExpressionBuilder;
        jsxAttribute: JSXAttributeBuilder;
        jsxIdentifier: JSXIdentifierBuilder;
        jsxNamespacedName: JSXNamespacedNameBuilder;
        jsxExpressionContainer: JSXExpressionContainerBuilder;
        jsxElement: JSXElementBuilder;
        jsxFragment: JSXFragmentBuilder;
        jsxMemberExpression: JSXMemberExpressionBuilder;
        jsxSpreadAttribute: JSXSpreadAttributeBuilder;
        jsxEmptyExpression: JSXEmptyExpressionBuilder;
        jsxText: JSXTextBuilder;
        jsxSpreadChild: JSXSpreadChildBuilder;
        jsxOpeningElement: JSXOpeningElementBuilder;
        jsxClosingElement: JSXClosingElementBuilder;
        jsxOpeningFragment: JSXOpeningFragmentBuilder;
        jsxClosingFragment: JSXClosingFragmentBuilder;
        decorator: DecoratorBuilder;
        privateName: PrivateNameBuilder;
        classPrivateProperty: ClassPrivatePropertyBuilder;
        typeParameterDeclaration: TypeParameterDeclarationBuilder;
        tsTypeParameterDeclaration: TSTypeParameterDeclarationBuilder;
        typeParameterInstantiation: TypeParameterInstantiationBuilder;
        tsTypeParameterInstantiation: TSTypeParameterInstantiationBuilder;
        classImplements: ClassImplementsBuilder;
        tsExpressionWithTypeArguments: TSExpressionWithTypeArgumentsBuilder;
        anyTypeAnnotation: AnyTypeAnnotationBuilder;
        emptyTypeAnnotation: EmptyTypeAnnotationBuilder;
        mixedTypeAnnotation: MixedTypeAnnotationBuilder;
        voidTypeAnnotation: VoidTypeAnnotationBuilder;
        symbolTypeAnnotation: SymbolTypeAnnotationBuilder;
        numberTypeAnnotation: NumberTypeAnnotationBuilder;
        bigIntTypeAnnotation: BigIntTypeAnnotationBuilder;
        numberLiteralTypeAnnotation: NumberLiteralTypeAnnotationBuilder;
        numericLiteralTypeAnnotation: NumericLiteralTypeAnnotationBuilder;
        bigIntLiteralTypeAnnotation: BigIntLiteralTypeAnnotationBuilder;
        stringTypeAnnotation: StringTypeAnnotationBuilder;
        stringLiteralTypeAnnotation: StringLiteralTypeAnnotationBuilder;
        booleanTypeAnnotation: BooleanTypeAnnotationBuilder;
        booleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotationBuilder;
        nullableTypeAnnotation: NullableTypeAnnotationBuilder;
        nullLiteralTypeAnnotation: NullLiteralTypeAnnotationBuilder;
        nullTypeAnnotation: NullTypeAnnotationBuilder;
        thisTypeAnnotation: ThisTypeAnnotationBuilder;
        existsTypeAnnotation: ExistsTypeAnnotationBuilder;
        existentialTypeParam: ExistentialTypeParamBuilder;
        functionTypeAnnotation: FunctionTypeAnnotationBuilder;
        functionTypeParam: FunctionTypeParamBuilder;
        arrayTypeAnnotation: ArrayTypeAnnotationBuilder;
        objectTypeAnnotation: ObjectTypeAnnotationBuilder;
        objectTypeProperty: ObjectTypePropertyBuilder;
        objectTypeSpreadProperty: ObjectTypeSpreadPropertyBuilder;
        objectTypeIndexer: ObjectTypeIndexerBuilder;
        objectTypeCallProperty: ObjectTypeCallPropertyBuilder;
        objectTypeInternalSlot: ObjectTypeInternalSlotBuilder;
        variance: VarianceBuilder;
        qualifiedTypeIdentifier: QualifiedTypeIdentifierBuilder;
        genericTypeAnnotation: GenericTypeAnnotationBuilder;
        memberTypeAnnotation: MemberTypeAnnotationBuilder;
        unionTypeAnnotation: UnionTypeAnnotationBuilder;
        intersectionTypeAnnotation: IntersectionTypeAnnotationBuilder;
        typeofTypeAnnotation: TypeofTypeAnnotationBuilder;
        typeParameter: TypeParameterBuilder;
        interfaceTypeAnnotation: InterfaceTypeAnnotationBuilder;
        interfaceExtends: InterfaceExtendsBuilder;
        interfaceDeclaration: InterfaceDeclarationBuilder;
        declareInterface: DeclareInterfaceBuilder;
        typeAlias: TypeAliasBuilder;
        declareTypeAlias: DeclareTypeAliasBuilder;
        opaqueType: OpaqueTypeBuilder;
        declareOpaqueType: DeclareOpaqueTypeBuilder;
        typeCastExpression: TypeCastExpressionBuilder;
        tupleTypeAnnotation: TupleTypeAnnotationBuilder;
        declareVariable: DeclareVariableBuilder;
        declareFunction: DeclareFunctionBuilder;
        declareClass: DeclareClassBuilder;
        declareModule: DeclareModuleBuilder;
        declareModuleExports: DeclareModuleExportsBuilder;
        declareExportDeclaration: DeclareExportDeclarationBuilder;
        exportBatchSpecifier: ExportBatchSpecifierBuilder;
        declareExportAllDeclaration: DeclareExportAllDeclarationBuilder;
        inferredPredicate: InferredPredicateBuilder;
        declaredPredicate: DeclaredPredicateBuilder;
        enumDeclaration: EnumDeclarationBuilder;
        enumBooleanBody: EnumBooleanBodyBuilder;
        enumNumberBody: EnumNumberBodyBuilder;
        enumStringBody: EnumStringBodyBuilder;
        enumSymbolBody: EnumSymbolBodyBuilder;
        enumBooleanMember: EnumBooleanMemberBuilder;
        enumNumberMember: EnumNumberMemberBuilder;
        enumStringMember: EnumStringMemberBuilder;
        enumDefaultedMember: EnumDefaultedMemberBuilder;
        exportDeclaration: ExportDeclarationBuilder;
        block: BlockBuilder;
        line: LineBuilder;
        noop: NoopBuilder;
        doExpression: DoExpressionBuilder;
        bindExpression: BindExpressionBuilder;
        parenthesizedExpression: ParenthesizedExpressionBuilder;
        exportNamespaceSpecifier: ExportNamespaceSpecifierBuilder;
        exportDefaultSpecifier: ExportDefaultSpecifierBuilder;
        commentBlock: CommentBlockBuilder;
        commentLine: CommentLineBuilder;
        directive: DirectiveBuilder;
        directiveLiteral: DirectiveLiteralBuilder;
        interpreterDirective: InterpreterDirectiveBuilder;
        stringLiteral: StringLiteralBuilder;
        numericLiteral: NumericLiteralBuilder;
        bigIntLiteral: BigIntLiteralBuilder;
        nullLiteral: NullLiteralBuilder;
        booleanLiteral: BooleanLiteralBuilder;
        regExpLiteral: RegExpLiteralBuilder;
        objectMethod: ObjectMethodBuilder;
        classMethod: ClassMethodBuilder;
        classPrivateMethod: ClassPrivateMethodBuilder;
        restProperty: RestPropertyBuilder;
        forAwaitStatement: ForAwaitStatementBuilder;
        import: ImportBuilder;
        tsQualifiedName: TSQualifiedNameBuilder;
        tsTypeReference: TSTypeReferenceBuilder;
        tsAsExpression: TSAsExpressionBuilder;
        tsNonNullExpression: TSNonNullExpressionBuilder;
        tsAnyKeyword: TSAnyKeywordBuilder;
        tsBigIntKeyword: TSBigIntKeywordBuilder;
        tsBooleanKeyword: TSBooleanKeywordBuilder;
        tsNeverKeyword: TSNeverKeywordBuilder;
        tsNullKeyword: TSNullKeywordBuilder;
        tsNumberKeyword: TSNumberKeywordBuilder;
        tsObjectKeyword: TSObjectKeywordBuilder;
        tsStringKeyword: TSStringKeywordBuilder;
        tsSymbolKeyword: TSSymbolKeywordBuilder;
        tsUndefinedKeyword: TSUndefinedKeywordBuilder;
        tsUnknownKeyword: TSUnknownKeywordBuilder;
        tsVoidKeyword: TSVoidKeywordBuilder;
        tsThisType: TSThisTypeBuilder;
        tsArrayType: TSArrayTypeBuilder;
        tsLiteralType: TSLiteralTypeBuilder;
        tsUnionType: TSUnionTypeBuilder;
        tsIntersectionType: TSIntersectionTypeBuilder;
        tsConditionalType: TSConditionalTypeBuilder;
        tsInferType: TSInferTypeBuilder;
        tsTypeParameter: TSTypeParameterBuilder;
        tsParenthesizedType: TSParenthesizedTypeBuilder;
        tsFunctionType: TSFunctionTypeBuilder;
        tsConstructorType: TSConstructorTypeBuilder;
        tsDeclareFunction: TSDeclareFunctionBuilder;
        tsDeclareMethod: TSDeclareMethodBuilder;
        tsMappedType: TSMappedTypeBuilder;
        tsTupleType: TSTupleTypeBuilder;
        tsNamedTupleMember: TSNamedTupleMemberBuilder;
        tsRestType: TSRestTypeBuilder;
        tsOptionalType: TSOptionalTypeBuilder;
        tsIndexedAccessType: TSIndexedAccessTypeBuilder;
        tsTypeOperator: TSTypeOperatorBuilder;
        tsIndexSignature: TSIndexSignatureBuilder;
        tsPropertySignature: TSPropertySignatureBuilder;
        tsMethodSignature: TSMethodSignatureBuilder;
        tsTypePredicate: TSTypePredicateBuilder;
        tsCallSignatureDeclaration: TSCallSignatureDeclarationBuilder;
        tsConstructSignatureDeclaration: TSConstructSignatureDeclarationBuilder;
        tsEnumMember: TSEnumMemberBuilder;
        tsTypeQuery: TSTypeQueryBuilder;
        tsImportType: TSImportTypeBuilder;
        tsTypeLiteral: TSTypeLiteralBuilder;
        tsTypeAssertion: TSTypeAssertionBuilder;
        tsEnumDeclaration: TSEnumDeclarationBuilder;
        tsTypeAliasDeclaration: TSTypeAliasDeclarationBuilder;
        tsModuleBlock: TSModuleBlockBuilder;
        tsModuleDeclaration: TSModuleDeclarationBuilder;
        tsImportEqualsDeclaration: TSImportEqualsDeclarationBuilder;
        tsExternalModuleReference: TSExternalModuleReferenceBuilder;
        tsExportAssignment: TSExportAssignmentBuilder;
        tsNamespaceExportDeclaration: TSNamespaceExportDeclarationBuilder;
        tsInterfaceBody: TSInterfaceBodyBuilder;
        tsInterfaceDeclaration: TSInterfaceDeclarationBuilder;
        tsParameterProperty: TSParameterPropertyBuilder;
        [builderName: string]: any;
    }
}

declare module 'ast-types/gen/visitor' {
    import { NodePath } from "ast-types/lib/node-path";
    import { Context } from "ast-types/lib/path-visitor";
    import { namedTypes } from "ast-types/gen/namedTypes";
    export interface Visitor<M = {}> {
        visitPrintable?(this: Context & M, path: NodePath<namedTypes.Printable>): any;
        visitSourceLocation?(this: Context & M, path: NodePath<namedTypes.SourceLocation>): any;
        visitNode?(this: Context & M, path: NodePath<namedTypes.Node>): any;
        visitComment?(this: Context & M, path: NodePath<namedTypes.Comment>): any;
        visitPosition?(this: Context & M, path: NodePath<namedTypes.Position>): any;
        visitFile?(this: Context & M, path: NodePath<namedTypes.File>): any;
        visitProgram?(this: Context & M, path: NodePath<namedTypes.Program>): any;
        visitStatement?(this: Context & M, path: NodePath<namedTypes.Statement>): any;
        visitFunction?(this: Context & M, path: NodePath<namedTypes.Function>): any;
        visitExpression?(this: Context & M, path: NodePath<namedTypes.Expression>): any;
        visitPattern?(this: Context & M, path: NodePath<namedTypes.Pattern>): any;
        visitIdentifier?(this: Context & M, path: NodePath<namedTypes.Identifier>): any;
        visitBlockStatement?(this: Context & M, path: NodePath<namedTypes.BlockStatement>): any;
        visitEmptyStatement?(this: Context & M, path: NodePath<namedTypes.EmptyStatement>): any;
        visitExpressionStatement?(this: Context & M, path: NodePath<namedTypes.ExpressionStatement>): any;
        visitIfStatement?(this: Context & M, path: NodePath<namedTypes.IfStatement>): any;
        visitLabeledStatement?(this: Context & M, path: NodePath<namedTypes.LabeledStatement>): any;
        visitBreakStatement?(this: Context & M, path: NodePath<namedTypes.BreakStatement>): any;
        visitContinueStatement?(this: Context & M, path: NodePath<namedTypes.ContinueStatement>): any;
        visitWithStatement?(this: Context & M, path: NodePath<namedTypes.WithStatement>): any;
        visitSwitchStatement?(this: Context & M, path: NodePath<namedTypes.SwitchStatement>): any;
        visitSwitchCase?(this: Context & M, path: NodePath<namedTypes.SwitchCase>): any;
        visitReturnStatement?(this: Context & M, path: NodePath<namedTypes.ReturnStatement>): any;
        visitThrowStatement?(this: Context & M, path: NodePath<namedTypes.ThrowStatement>): any;
        visitTryStatement?(this: Context & M, path: NodePath<namedTypes.TryStatement>): any;
        visitCatchClause?(this: Context & M, path: NodePath<namedTypes.CatchClause>): any;
        visitWhileStatement?(this: Context & M, path: NodePath<namedTypes.WhileStatement>): any;
        visitDoWhileStatement?(this: Context & M, path: NodePath<namedTypes.DoWhileStatement>): any;
        visitForStatement?(this: Context & M, path: NodePath<namedTypes.ForStatement>): any;
        visitDeclaration?(this: Context & M, path: NodePath<namedTypes.Declaration>): any;
        visitVariableDeclaration?(this: Context & M, path: NodePath<namedTypes.VariableDeclaration>): any;
        visitForInStatement?(this: Context & M, path: NodePath<namedTypes.ForInStatement>): any;
        visitDebuggerStatement?(this: Context & M, path: NodePath<namedTypes.DebuggerStatement>): any;
        visitFunctionDeclaration?(this: Context & M, path: NodePath<namedTypes.FunctionDeclaration>): any;
        visitFunctionExpression?(this: Context & M, path: NodePath<namedTypes.FunctionExpression>): any;
        visitVariableDeclarator?(this: Context & M, path: NodePath<namedTypes.VariableDeclarator>): any;
        visitThisExpression?(this: Context & M, path: NodePath<namedTypes.ThisExpression>): any;
        visitArrayExpression?(this: Context & M, path: NodePath<namedTypes.ArrayExpression>): any;
        visitObjectExpression?(this: Context & M, path: NodePath<namedTypes.ObjectExpression>): any;
        visitProperty?(this: Context & M, path: NodePath<namedTypes.Property>): any;
        visitLiteral?(this: Context & M, path: NodePath<namedTypes.Literal>): any;
        visitSequenceExpression?(this: Context & M, path: NodePath<namedTypes.SequenceExpression>): any;
        visitUnaryExpression?(this: Context & M, path: NodePath<namedTypes.UnaryExpression>): any;
        visitBinaryExpression?(this: Context & M, path: NodePath<namedTypes.BinaryExpression>): any;
        visitAssignmentExpression?(this: Context & M, path: NodePath<namedTypes.AssignmentExpression>): any;
        visitChainElement?(this: Context & M, path: NodePath<namedTypes.ChainElement>): any;
        visitMemberExpression?(this: Context & M, path: NodePath<namedTypes.MemberExpression>): any;
        visitUpdateExpression?(this: Context & M, path: NodePath<namedTypes.UpdateExpression>): any;
        visitLogicalExpression?(this: Context & M, path: NodePath<namedTypes.LogicalExpression>): any;
        visitConditionalExpression?(this: Context & M, path: NodePath<namedTypes.ConditionalExpression>): any;
        visitNewExpression?(this: Context & M, path: NodePath<namedTypes.NewExpression>): any;
        visitCallExpression?(this: Context & M, path: NodePath<namedTypes.CallExpression>): any;
        visitRestElement?(this: Context & M, path: NodePath<namedTypes.RestElement>): any;
        visitTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.TypeAnnotation>): any;
        visitTSTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.TSTypeAnnotation>): any;
        visitSpreadElementPattern?(this: Context & M, path: NodePath<namedTypes.SpreadElementPattern>): any;
        visitArrowFunctionExpression?(this: Context & M, path: NodePath<namedTypes.ArrowFunctionExpression>): any;
        visitForOfStatement?(this: Context & M, path: NodePath<namedTypes.ForOfStatement>): any;
        visitYieldExpression?(this: Context & M, path: NodePath<namedTypes.YieldExpression>): any;
        visitGeneratorExpression?(this: Context & M, path: NodePath<namedTypes.GeneratorExpression>): any;
        visitComprehensionBlock?(this: Context & M, path: NodePath<namedTypes.ComprehensionBlock>): any;
        visitComprehensionExpression?(this: Context & M, path: NodePath<namedTypes.ComprehensionExpression>): any;
        visitObjectProperty?(this: Context & M, path: NodePath<namedTypes.ObjectProperty>): any;
        visitPropertyPattern?(this: Context & M, path: NodePath<namedTypes.PropertyPattern>): any;
        visitObjectPattern?(this: Context & M, path: NodePath<namedTypes.ObjectPattern>): any;
        visitArrayPattern?(this: Context & M, path: NodePath<namedTypes.ArrayPattern>): any;
        visitSpreadElement?(this: Context & M, path: NodePath<namedTypes.SpreadElement>): any;
        visitAssignmentPattern?(this: Context & M, path: NodePath<namedTypes.AssignmentPattern>): any;
        visitMethodDefinition?(this: Context & M, path: NodePath<namedTypes.MethodDefinition>): any;
        visitClassPropertyDefinition?(this: Context & M, path: NodePath<namedTypes.ClassPropertyDefinition>): any;
        visitClassProperty?(this: Context & M, path: NodePath<namedTypes.ClassProperty>): any;
        visitClassBody?(this: Context & M, path: NodePath<namedTypes.ClassBody>): any;
        visitClassDeclaration?(this: Context & M, path: NodePath<namedTypes.ClassDeclaration>): any;
        visitClassExpression?(this: Context & M, path: NodePath<namedTypes.ClassExpression>): any;
        visitSuper?(this: Context & M, path: NodePath<namedTypes.Super>): any;
        visitSpecifier?(this: Context & M, path: NodePath<namedTypes.Specifier>): any;
        visitModuleSpecifier?(this: Context & M, path: NodePath<namedTypes.ModuleSpecifier>): any;
        visitImportSpecifier?(this: Context & M, path: NodePath<namedTypes.ImportSpecifier>): any;
        visitImportDefaultSpecifier?(this: Context & M, path: NodePath<namedTypes.ImportDefaultSpecifier>): any;
        visitImportNamespaceSpecifier?(this: Context & M, path: NodePath<namedTypes.ImportNamespaceSpecifier>): any;
        visitImportDeclaration?(this: Context & M, path: NodePath<namedTypes.ImportDeclaration>): any;
        visitExportNamedDeclaration?(this: Context & M, path: NodePath<namedTypes.ExportNamedDeclaration>): any;
        visitExportSpecifier?(this: Context & M, path: NodePath<namedTypes.ExportSpecifier>): any;
        visitExportDefaultDeclaration?(this: Context & M, path: NodePath<namedTypes.ExportDefaultDeclaration>): any;
        visitExportAllDeclaration?(this: Context & M, path: NodePath<namedTypes.ExportAllDeclaration>): any;
        visitTaggedTemplateExpression?(this: Context & M, path: NodePath<namedTypes.TaggedTemplateExpression>): any;
        visitTemplateLiteral?(this: Context & M, path: NodePath<namedTypes.TemplateLiteral>): any;
        visitTemplateElement?(this: Context & M, path: NodePath<namedTypes.TemplateElement>): any;
        visitMetaProperty?(this: Context & M, path: NodePath<namedTypes.MetaProperty>): any;
        visitAwaitExpression?(this: Context & M, path: NodePath<namedTypes.AwaitExpression>): any;
        visitSpreadProperty?(this: Context & M, path: NodePath<namedTypes.SpreadProperty>): any;
        visitSpreadPropertyPattern?(this: Context & M, path: NodePath<namedTypes.SpreadPropertyPattern>): any;
        visitImportExpression?(this: Context & M, path: NodePath<namedTypes.ImportExpression>): any;
        visitChainExpression?(this: Context & M, path: NodePath<namedTypes.ChainExpression>): any;
        visitOptionalCallExpression?(this: Context & M, path: NodePath<namedTypes.OptionalCallExpression>): any;
        visitOptionalMemberExpression?(this: Context & M, path: NodePath<namedTypes.OptionalMemberExpression>): any;
        visitJSXAttribute?(this: Context & M, path: NodePath<namedTypes.JSXAttribute>): any;
        visitJSXIdentifier?(this: Context & M, path: NodePath<namedTypes.JSXIdentifier>): any;
        visitJSXNamespacedName?(this: Context & M, path: NodePath<namedTypes.JSXNamespacedName>): any;
        visitJSXExpressionContainer?(this: Context & M, path: NodePath<namedTypes.JSXExpressionContainer>): any;
        visitJSXElement?(this: Context & M, path: NodePath<namedTypes.JSXElement>): any;
        visitJSXFragment?(this: Context & M, path: NodePath<namedTypes.JSXFragment>): any;
        visitJSXMemberExpression?(this: Context & M, path: NodePath<namedTypes.JSXMemberExpression>): any;
        visitJSXSpreadAttribute?(this: Context & M, path: NodePath<namedTypes.JSXSpreadAttribute>): any;
        visitJSXEmptyExpression?(this: Context & M, path: NodePath<namedTypes.JSXEmptyExpression>): any;
        visitJSXText?(this: Context & M, path: NodePath<namedTypes.JSXText>): any;
        visitJSXSpreadChild?(this: Context & M, path: NodePath<namedTypes.JSXSpreadChild>): any;
        visitJSXOpeningElement?(this: Context & M, path: NodePath<namedTypes.JSXOpeningElement>): any;
        visitJSXClosingElement?(this: Context & M, path: NodePath<namedTypes.JSXClosingElement>): any;
        visitJSXOpeningFragment?(this: Context & M, path: NodePath<namedTypes.JSXOpeningFragment>): any;
        visitJSXClosingFragment?(this: Context & M, path: NodePath<namedTypes.JSXClosingFragment>): any;
        visitDecorator?(this: Context & M, path: NodePath<namedTypes.Decorator>): any;
        visitPrivateName?(this: Context & M, path: NodePath<namedTypes.PrivateName>): any;
        visitClassPrivateProperty?(this: Context & M, path: NodePath<namedTypes.ClassPrivateProperty>): any;
        visitTypeParameterDeclaration?(this: Context & M, path: NodePath<namedTypes.TypeParameterDeclaration>): any;
        visitTSTypeParameterDeclaration?(this: Context & M, path: NodePath<namedTypes.TSTypeParameterDeclaration>): any;
        visitTypeParameterInstantiation?(this: Context & M, path: NodePath<namedTypes.TypeParameterInstantiation>): any;
        visitTSTypeParameterInstantiation?(this: Context & M, path: NodePath<namedTypes.TSTypeParameterInstantiation>): any;
        visitClassImplements?(this: Context & M, path: NodePath<namedTypes.ClassImplements>): any;
        visitTSType?(this: Context & M, path: NodePath<namedTypes.TSType>): any;
        visitTSHasOptionalTypeParameterInstantiation?(this: Context & M, path: NodePath<namedTypes.TSHasOptionalTypeParameterInstantiation>): any;
        visitTSExpressionWithTypeArguments?(this: Context & M, path: NodePath<namedTypes.TSExpressionWithTypeArguments>): any;
        visitFlow?(this: Context & M, path: NodePath<namedTypes.Flow>): any;
        visitFlowType?(this: Context & M, path: NodePath<namedTypes.FlowType>): any;
        visitAnyTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.AnyTypeAnnotation>): any;
        visitEmptyTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.EmptyTypeAnnotation>): any;
        visitMixedTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.MixedTypeAnnotation>): any;
        visitVoidTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.VoidTypeAnnotation>): any;
        visitSymbolTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.SymbolTypeAnnotation>): any;
        visitNumberTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.NumberTypeAnnotation>): any;
        visitBigIntTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.BigIntTypeAnnotation>): any;
        visitNumberLiteralTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.NumberLiteralTypeAnnotation>): any;
        visitNumericLiteralTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.NumericLiteralTypeAnnotation>): any;
        visitBigIntLiteralTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.BigIntLiteralTypeAnnotation>): any;
        visitStringTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.StringTypeAnnotation>): any;
        visitStringLiteralTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.StringLiteralTypeAnnotation>): any;
        visitBooleanTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.BooleanTypeAnnotation>): any;
        visitBooleanLiteralTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.BooleanLiteralTypeAnnotation>): any;
        visitNullableTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.NullableTypeAnnotation>): any;
        visitNullLiteralTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.NullLiteralTypeAnnotation>): any;
        visitNullTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.NullTypeAnnotation>): any;
        visitThisTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.ThisTypeAnnotation>): any;
        visitExistsTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.ExistsTypeAnnotation>): any;
        visitExistentialTypeParam?(this: Context & M, path: NodePath<namedTypes.ExistentialTypeParam>): any;
        visitFunctionTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.FunctionTypeAnnotation>): any;
        visitFunctionTypeParam?(this: Context & M, path: NodePath<namedTypes.FunctionTypeParam>): any;
        visitArrayTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.ArrayTypeAnnotation>): any;
        visitObjectTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.ObjectTypeAnnotation>): any;
        visitObjectTypeProperty?(this: Context & M, path: NodePath<namedTypes.ObjectTypeProperty>): any;
        visitObjectTypeSpreadProperty?(this: Context & M, path: NodePath<namedTypes.ObjectTypeSpreadProperty>): any;
        visitObjectTypeIndexer?(this: Context & M, path: NodePath<namedTypes.ObjectTypeIndexer>): any;
        visitObjectTypeCallProperty?(this: Context & M, path: NodePath<namedTypes.ObjectTypeCallProperty>): any;
        visitObjectTypeInternalSlot?(this: Context & M, path: NodePath<namedTypes.ObjectTypeInternalSlot>): any;
        visitVariance?(this: Context & M, path: NodePath<namedTypes.Variance>): any;
        visitQualifiedTypeIdentifier?(this: Context & M, path: NodePath<namedTypes.QualifiedTypeIdentifier>): any;
        visitGenericTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.GenericTypeAnnotation>): any;
        visitMemberTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.MemberTypeAnnotation>): any;
        visitUnionTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.UnionTypeAnnotation>): any;
        visitIntersectionTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.IntersectionTypeAnnotation>): any;
        visitTypeofTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.TypeofTypeAnnotation>): any;
        visitTypeParameter?(this: Context & M, path: NodePath<namedTypes.TypeParameter>): any;
        visitInterfaceTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.InterfaceTypeAnnotation>): any;
        visitInterfaceExtends?(this: Context & M, path: NodePath<namedTypes.InterfaceExtends>): any;
        visitInterfaceDeclaration?(this: Context & M, path: NodePath<namedTypes.InterfaceDeclaration>): any;
        visitDeclareInterface?(this: Context & M, path: NodePath<namedTypes.DeclareInterface>): any;
        visitTypeAlias?(this: Context & M, path: NodePath<namedTypes.TypeAlias>): any;
        visitDeclareTypeAlias?(this: Context & M, path: NodePath<namedTypes.DeclareTypeAlias>): any;
        visitOpaqueType?(this: Context & M, path: NodePath<namedTypes.OpaqueType>): any;
        visitDeclareOpaqueType?(this: Context & M, path: NodePath<namedTypes.DeclareOpaqueType>): any;
        visitTypeCastExpression?(this: Context & M, path: NodePath<namedTypes.TypeCastExpression>): any;
        visitTupleTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.TupleTypeAnnotation>): any;
        visitDeclareVariable?(this: Context & M, path: NodePath<namedTypes.DeclareVariable>): any;
        visitDeclareFunction?(this: Context & M, path: NodePath<namedTypes.DeclareFunction>): any;
        visitFlowPredicate?(this: Context & M, path: NodePath<namedTypes.FlowPredicate>): any;
        visitDeclareClass?(this: Context & M, path: NodePath<namedTypes.DeclareClass>): any;
        visitDeclareModule?(this: Context & M, path: NodePath<namedTypes.DeclareModule>): any;
        visitDeclareModuleExports?(this: Context & M, path: NodePath<namedTypes.DeclareModuleExports>): any;
        visitDeclareExportDeclaration?(this: Context & M, path: NodePath<namedTypes.DeclareExportDeclaration>): any;
        visitExportBatchSpecifier?(this: Context & M, path: NodePath<namedTypes.ExportBatchSpecifier>): any;
        visitDeclareExportAllDeclaration?(this: Context & M, path: NodePath<namedTypes.DeclareExportAllDeclaration>): any;
        visitInferredPredicate?(this: Context & M, path: NodePath<namedTypes.InferredPredicate>): any;
        visitDeclaredPredicate?(this: Context & M, path: NodePath<namedTypes.DeclaredPredicate>): any;
        visitEnumDeclaration?(this: Context & M, path: NodePath<namedTypes.EnumDeclaration>): any;
        visitEnumBooleanBody?(this: Context & M, path: NodePath<namedTypes.EnumBooleanBody>): any;
        visitEnumNumberBody?(this: Context & M, path: NodePath<namedTypes.EnumNumberBody>): any;
        visitEnumStringBody?(this: Context & M, path: NodePath<namedTypes.EnumStringBody>): any;
        visitEnumSymbolBody?(this: Context & M, path: NodePath<namedTypes.EnumSymbolBody>): any;
        visitEnumBooleanMember?(this: Context & M, path: NodePath<namedTypes.EnumBooleanMember>): any;
        visitEnumNumberMember?(this: Context & M, path: NodePath<namedTypes.EnumNumberMember>): any;
        visitEnumStringMember?(this: Context & M, path: NodePath<namedTypes.EnumStringMember>): any;
        visitEnumDefaultedMember?(this: Context & M, path: NodePath<namedTypes.EnumDefaultedMember>): any;
        visitExportDeclaration?(this: Context & M, path: NodePath<namedTypes.ExportDeclaration>): any;
        visitBlock?(this: Context & M, path: NodePath<namedTypes.Block>): any;
        visitLine?(this: Context & M, path: NodePath<namedTypes.Line>): any;
        visitNoop?(this: Context & M, path: NodePath<namedTypes.Noop>): any;
        visitDoExpression?(this: Context & M, path: NodePath<namedTypes.DoExpression>): any;
        visitBindExpression?(this: Context & M, path: NodePath<namedTypes.BindExpression>): any;
        visitParenthesizedExpression?(this: Context & M, path: NodePath<namedTypes.ParenthesizedExpression>): any;
        visitExportNamespaceSpecifier?(this: Context & M, path: NodePath<namedTypes.ExportNamespaceSpecifier>): any;
        visitExportDefaultSpecifier?(this: Context & M, path: NodePath<namedTypes.ExportDefaultSpecifier>): any;
        visitCommentBlock?(this: Context & M, path: NodePath<namedTypes.CommentBlock>): any;
        visitCommentLine?(this: Context & M, path: NodePath<namedTypes.CommentLine>): any;
        visitDirective?(this: Context & M, path: NodePath<namedTypes.Directive>): any;
        visitDirectiveLiteral?(this: Context & M, path: NodePath<namedTypes.DirectiveLiteral>): any;
        visitInterpreterDirective?(this: Context & M, path: NodePath<namedTypes.InterpreterDirective>): any;
        visitStringLiteral?(this: Context & M, path: NodePath<namedTypes.StringLiteral>): any;
        visitNumericLiteral?(this: Context & M, path: NodePath<namedTypes.NumericLiteral>): any;
        visitBigIntLiteral?(this: Context & M, path: NodePath<namedTypes.BigIntLiteral>): any;
        visitNullLiteral?(this: Context & M, path: NodePath<namedTypes.NullLiteral>): any;
        visitBooleanLiteral?(this: Context & M, path: NodePath<namedTypes.BooleanLiteral>): any;
        visitRegExpLiteral?(this: Context & M, path: NodePath<namedTypes.RegExpLiteral>): any;
        visitObjectMethod?(this: Context & M, path: NodePath<namedTypes.ObjectMethod>): any;
        visitClassMethod?(this: Context & M, path: NodePath<namedTypes.ClassMethod>): any;
        visitClassPrivateMethod?(this: Context & M, path: NodePath<namedTypes.ClassPrivateMethod>): any;
        visitRestProperty?(this: Context & M, path: NodePath<namedTypes.RestProperty>): any;
        visitForAwaitStatement?(this: Context & M, path: NodePath<namedTypes.ForAwaitStatement>): any;
        visitImport?(this: Context & M, path: NodePath<namedTypes.Import>): any;
        visitTSQualifiedName?(this: Context & M, path: NodePath<namedTypes.TSQualifiedName>): any;
        visitTSTypeReference?(this: Context & M, path: NodePath<namedTypes.TSTypeReference>): any;
        visitTSHasOptionalTypeParameters?(this: Context & M, path: NodePath<namedTypes.TSHasOptionalTypeParameters>): any;
        visitTSHasOptionalTypeAnnotation?(this: Context & M, path: NodePath<namedTypes.TSHasOptionalTypeAnnotation>): any;
        visitTSAsExpression?(this: Context & M, path: NodePath<namedTypes.TSAsExpression>): any;
        visitTSNonNullExpression?(this: Context & M, path: NodePath<namedTypes.TSNonNullExpression>): any;
        visitTSAnyKeyword?(this: Context & M, path: NodePath<namedTypes.TSAnyKeyword>): any;
        visitTSBigIntKeyword?(this: Context & M, path: NodePath<namedTypes.TSBigIntKeyword>): any;
        visitTSBooleanKeyword?(this: Context & M, path: NodePath<namedTypes.TSBooleanKeyword>): any;
        visitTSNeverKeyword?(this: Context & M, path: NodePath<namedTypes.TSNeverKeyword>): any;
        visitTSNullKeyword?(this: Context & M, path: NodePath<namedTypes.TSNullKeyword>): any;
        visitTSNumberKeyword?(this: Context & M, path: NodePath<namedTypes.TSNumberKeyword>): any;
        visitTSObjectKeyword?(this: Context & M, path: NodePath<namedTypes.TSObjectKeyword>): any;
        visitTSStringKeyword?(this: Context & M, path: NodePath<namedTypes.TSStringKeyword>): any;
        visitTSSymbolKeyword?(this: Context & M, path: NodePath<namedTypes.TSSymbolKeyword>): any;
        visitTSUndefinedKeyword?(this: Context & M, path: NodePath<namedTypes.TSUndefinedKeyword>): any;
        visitTSUnknownKeyword?(this: Context & M, path: NodePath<namedTypes.TSUnknownKeyword>): any;
        visitTSVoidKeyword?(this: Context & M, path: NodePath<namedTypes.TSVoidKeyword>): any;
        visitTSThisType?(this: Context & M, path: NodePath<namedTypes.TSThisType>): any;
        visitTSArrayType?(this: Context & M, path: NodePath<namedTypes.TSArrayType>): any;
        visitTSLiteralType?(this: Context & M, path: NodePath<namedTypes.TSLiteralType>): any;
        visitTSUnionType?(this: Context & M, path: NodePath<namedTypes.TSUnionType>): any;
        visitTSIntersectionType?(this: Context & M, path: NodePath<namedTypes.TSIntersectionType>): any;
        visitTSConditionalType?(this: Context & M, path: NodePath<namedTypes.TSConditionalType>): any;
        visitTSInferType?(this: Context & M, path: NodePath<namedTypes.TSInferType>): any;
        visitTSTypeParameter?(this: Context & M, path: NodePath<namedTypes.TSTypeParameter>): any;
        visitTSParenthesizedType?(this: Context & M, path: NodePath<namedTypes.TSParenthesizedType>): any;
        visitTSFunctionType?(this: Context & M, path: NodePath<namedTypes.TSFunctionType>): any;
        visitTSConstructorType?(this: Context & M, path: NodePath<namedTypes.TSConstructorType>): any;
        visitTSDeclareFunction?(this: Context & M, path: NodePath<namedTypes.TSDeclareFunction>): any;
        visitTSDeclareMethod?(this: Context & M, path: NodePath<namedTypes.TSDeclareMethod>): any;
        visitTSMappedType?(this: Context & M, path: NodePath<namedTypes.TSMappedType>): any;
        visitTSTupleType?(this: Context & M, path: NodePath<namedTypes.TSTupleType>): any;
        visitTSNamedTupleMember?(this: Context & M, path: NodePath<namedTypes.TSNamedTupleMember>): any;
        visitTSRestType?(this: Context & M, path: NodePath<namedTypes.TSRestType>): any;
        visitTSOptionalType?(this: Context & M, path: NodePath<namedTypes.TSOptionalType>): any;
        visitTSIndexedAccessType?(this: Context & M, path: NodePath<namedTypes.TSIndexedAccessType>): any;
        visitTSTypeOperator?(this: Context & M, path: NodePath<namedTypes.TSTypeOperator>): any;
        visitTSIndexSignature?(this: Context & M, path: NodePath<namedTypes.TSIndexSignature>): any;
        visitTSPropertySignature?(this: Context & M, path: NodePath<namedTypes.TSPropertySignature>): any;
        visitTSMethodSignature?(this: Context & M, path: NodePath<namedTypes.TSMethodSignature>): any;
        visitTSTypePredicate?(this: Context & M, path: NodePath<namedTypes.TSTypePredicate>): any;
        visitTSCallSignatureDeclaration?(this: Context & M, path: NodePath<namedTypes.TSCallSignatureDeclaration>): any;
        visitTSConstructSignatureDeclaration?(this: Context & M, path: NodePath<namedTypes.TSConstructSignatureDeclaration>): any;
        visitTSEnumMember?(this: Context & M, path: NodePath<namedTypes.TSEnumMember>): any;
        visitTSTypeQuery?(this: Context & M, path: NodePath<namedTypes.TSTypeQuery>): any;
        visitTSImportType?(this: Context & M, path: NodePath<namedTypes.TSImportType>): any;
        visitTSTypeLiteral?(this: Context & M, path: NodePath<namedTypes.TSTypeLiteral>): any;
        visitTSTypeAssertion?(this: Context & M, path: NodePath<namedTypes.TSTypeAssertion>): any;
        visitTSEnumDeclaration?(this: Context & M, path: NodePath<namedTypes.TSEnumDeclaration>): any;
        visitTSTypeAliasDeclaration?(this: Context & M, path: NodePath<namedTypes.TSTypeAliasDeclaration>): any;
        visitTSModuleBlock?(this: Context & M, path: NodePath<namedTypes.TSModuleBlock>): any;
        visitTSModuleDeclaration?(this: Context & M, path: NodePath<namedTypes.TSModuleDeclaration>): any;
        visitTSImportEqualsDeclaration?(this: Context & M, path: NodePath<namedTypes.TSImportEqualsDeclaration>): any;
        visitTSExternalModuleReference?(this: Context & M, path: NodePath<namedTypes.TSExternalModuleReference>): any;
        visitTSExportAssignment?(this: Context & M, path: NodePath<namedTypes.TSExportAssignment>): any;
        visitTSNamespaceExportDeclaration?(this: Context & M, path: NodePath<namedTypes.TSNamespaceExportDeclaration>): any;
        visitTSInterfaceBody?(this: Context & M, path: NodePath<namedTypes.TSInterfaceBody>): any;
        visitTSInterfaceDeclaration?(this: Context & M, path: NodePath<namedTypes.TSInterfaceDeclaration>): any;
        visitTSParameterProperty?(this: Context & M, path: NodePath<namedTypes.TSParameterProperty>): any;
    }
}

declare module 'ast-types/types' {
    export type Fork = {
        use<T>(plugin: Plugin<T>): T;
    };
    export type Plugin<T> = (fork: Fork) => T;
    export type Def = Plugin<void>;
    export type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;
}

declare module 'ast-types/lib/path' {
    import { Fork } from "ast-types/types";
    import { ASTNode } from "ast-types/lib/types";
    export interface Path<V = any> {
        value: V;
        parentPath: any;
        name: any;
        __childCache: object | null;
        getValueProperty(name: any): any;
        get(...names: any[]): any;
        each(callback: any, context: any): any;
        map(callback: any, context: any): any;
        filter(callback: any, context: any): any;
        shift(): any;
        unshift(...args: any[]): any;
        push(...args: any[]): any;
        pop(): any;
        insertAt(index: number, ...args: any[]): any;
        insertBefore(...args: any[]): any;
        insertAfter(...args: any[]): any;
        replace(replacement?: ASTNode, ...args: ASTNode[]): any;
    }
    export interface PathConstructor {
        new <V = any>(value: any, parentPath?: any, name?: any): Path<V>;
    }
    export default function pathPlugin(fork: Fork): PathConstructor;
}

declare module 'ast-types/lib/scope' {
    import { Fork } from "ast-types/types";
    export interface Scope {
        path: any;
        node: any;
        isGlobal: boolean;
        depth: number;
        parent: any;
        bindings: any;
        types: any;
        didScan: boolean;
        declares(name: any): any;
        declaresType(name: any): any;
        declareTemporary(prefix?: any): any;
        injectTemporary(identifier: any, init: any): any;
        scan(force?: any): any;
        getBindings(): any;
        getTypes(): any;
        lookup(name: any): any;
        lookupType(name: any): any;
        getGlobalScope(): Scope;
    }
    export interface ScopeConstructor {
        new (path: any, parentScope: any): Scope;
        isEstablishedBy(node: any): any;
    }
    export default function scopePlugin(fork: Fork): ScopeConstructor;
}

declare module 'ast-types/gen/kinds' {
    import { namedTypes } from "ast-types/gen/namedTypes";
    export type PrintableKind = namedTypes.File | namedTypes.Program | namedTypes.Identifier | namedTypes.BlockStatement | namedTypes.EmptyStatement | namedTypes.ExpressionStatement | namedTypes.IfStatement | namedTypes.LabeledStatement | namedTypes.BreakStatement | namedTypes.ContinueStatement | namedTypes.WithStatement | namedTypes.SwitchStatement | namedTypes.SwitchCase | namedTypes.ReturnStatement | namedTypes.ThrowStatement | namedTypes.TryStatement | namedTypes.CatchClause | namedTypes.WhileStatement | namedTypes.DoWhileStatement | namedTypes.ForStatement | namedTypes.VariableDeclaration | namedTypes.ForInStatement | namedTypes.DebuggerStatement | namedTypes.FunctionDeclaration | namedTypes.FunctionExpression | namedTypes.VariableDeclarator | namedTypes.ThisExpression | namedTypes.ArrayExpression | namedTypes.ObjectExpression | namedTypes.Property | namedTypes.Literal | namedTypes.SequenceExpression | namedTypes.UnaryExpression | namedTypes.BinaryExpression | namedTypes.AssignmentExpression | namedTypes.MemberExpression | namedTypes.UpdateExpression | namedTypes.LogicalExpression | namedTypes.ConditionalExpression | namedTypes.NewExpression | namedTypes.CallExpression | namedTypes.RestElement | namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | namedTypes.SpreadElementPattern | namedTypes.ArrowFunctionExpression | namedTypes.ForOfStatement | namedTypes.YieldExpression | namedTypes.GeneratorExpression | namedTypes.ComprehensionBlock | namedTypes.ComprehensionExpression | namedTypes.ObjectProperty | namedTypes.PropertyPattern | namedTypes.ObjectPattern | namedTypes.ArrayPattern | namedTypes.SpreadElement | namedTypes.AssignmentPattern | namedTypes.MethodDefinition | namedTypes.ClassPropertyDefinition | namedTypes.ClassProperty | namedTypes.ClassBody | namedTypes.ClassDeclaration | namedTypes.ClassExpression | namedTypes.Super | namedTypes.ImportSpecifier | namedTypes.ImportDefaultSpecifier | namedTypes.ImportNamespaceSpecifier | namedTypes.ImportDeclaration | namedTypes.ExportNamedDeclaration | namedTypes.ExportSpecifier | namedTypes.ExportDefaultDeclaration | namedTypes.ExportAllDeclaration | namedTypes.TaggedTemplateExpression | namedTypes.TemplateLiteral | namedTypes.TemplateElement | namedTypes.MetaProperty | namedTypes.AwaitExpression | namedTypes.SpreadProperty | namedTypes.SpreadPropertyPattern | namedTypes.ImportExpression | namedTypes.ChainExpression | namedTypes.OptionalCallExpression | namedTypes.OptionalMemberExpression | namedTypes.JSXAttribute | namedTypes.JSXIdentifier | namedTypes.JSXNamespacedName | namedTypes.JSXExpressionContainer | namedTypes.JSXElement | namedTypes.JSXFragment | namedTypes.JSXMemberExpression | namedTypes.JSXSpreadAttribute | namedTypes.JSXEmptyExpression | namedTypes.JSXText | namedTypes.JSXSpreadChild | namedTypes.JSXOpeningElement | namedTypes.JSXClosingElement | namedTypes.JSXOpeningFragment | namedTypes.JSXClosingFragment | namedTypes.Decorator | namedTypes.PrivateName | namedTypes.ClassPrivateProperty | namedTypes.TypeParameterDeclaration | namedTypes.TSTypeParameterDeclaration | namedTypes.TypeParameterInstantiation | namedTypes.TSTypeParameterInstantiation | namedTypes.ClassImplements | namedTypes.TSExpressionWithTypeArguments | namedTypes.AnyTypeAnnotation | namedTypes.EmptyTypeAnnotation | namedTypes.MixedTypeAnnotation | namedTypes.VoidTypeAnnotation | namedTypes.SymbolTypeAnnotation | namedTypes.NumberTypeAnnotation | namedTypes.BigIntTypeAnnotation | namedTypes.NumberLiteralTypeAnnotation | namedTypes.NumericLiteralTypeAnnotation | namedTypes.BigIntLiteralTypeAnnotation | namedTypes.StringTypeAnnotation | namedTypes.StringLiteralTypeAnnotation | namedTypes.BooleanTypeAnnotation | namedTypes.BooleanLiteralTypeAnnotation | namedTypes.NullableTypeAnnotation | namedTypes.NullLiteralTypeAnnotation | namedTypes.NullTypeAnnotation | namedTypes.ThisTypeAnnotation | namedTypes.ExistsTypeAnnotation | namedTypes.ExistentialTypeParam | namedTypes.FunctionTypeAnnotation | namedTypes.FunctionTypeParam | namedTypes.ArrayTypeAnnotation | namedTypes.ObjectTypeAnnotation | namedTypes.ObjectTypeProperty | namedTypes.ObjectTypeSpreadProperty | namedTypes.ObjectTypeIndexer | namedTypes.ObjectTypeCallProperty | namedTypes.ObjectTypeInternalSlot | namedTypes.Variance | namedTypes.QualifiedTypeIdentifier | namedTypes.GenericTypeAnnotation | namedTypes.MemberTypeAnnotation | namedTypes.UnionTypeAnnotation | namedTypes.IntersectionTypeAnnotation | namedTypes.TypeofTypeAnnotation | namedTypes.TypeParameter | namedTypes.InterfaceTypeAnnotation | namedTypes.InterfaceExtends | namedTypes.InterfaceDeclaration | namedTypes.DeclareInterface | namedTypes.TypeAlias | namedTypes.DeclareTypeAlias | namedTypes.OpaqueType | namedTypes.DeclareOpaqueType | namedTypes.TypeCastExpression | namedTypes.TupleTypeAnnotation | namedTypes.DeclareVariable | namedTypes.DeclareFunction | namedTypes.DeclareClass | namedTypes.DeclareModule | namedTypes.DeclareModuleExports | namedTypes.DeclareExportDeclaration | namedTypes.ExportBatchSpecifier | namedTypes.DeclareExportAllDeclaration | namedTypes.InferredPredicate | namedTypes.DeclaredPredicate | namedTypes.EnumDeclaration | namedTypes.ExportDeclaration | namedTypes.Block | namedTypes.Line | namedTypes.Noop | namedTypes.DoExpression | namedTypes.BindExpression | namedTypes.ParenthesizedExpression | namedTypes.ExportNamespaceSpecifier | namedTypes.ExportDefaultSpecifier | namedTypes.CommentBlock | namedTypes.CommentLine | namedTypes.Directive | namedTypes.DirectiveLiteral | namedTypes.InterpreterDirective | namedTypes.StringLiteral | namedTypes.NumericLiteral | namedTypes.BigIntLiteral | namedTypes.NullLiteral | namedTypes.BooleanLiteral | namedTypes.RegExpLiteral | namedTypes.ObjectMethod | namedTypes.ClassMethod | namedTypes.ClassPrivateMethod | namedTypes.RestProperty | namedTypes.ForAwaitStatement | namedTypes.Import | namedTypes.TSQualifiedName | namedTypes.TSTypeReference | namedTypes.TSAsExpression | namedTypes.TSNonNullExpression | namedTypes.TSAnyKeyword | namedTypes.TSBigIntKeyword | namedTypes.TSBooleanKeyword | namedTypes.TSNeverKeyword | namedTypes.TSNullKeyword | namedTypes.TSNumberKeyword | namedTypes.TSObjectKeyword | namedTypes.TSStringKeyword | namedTypes.TSSymbolKeyword | namedTypes.TSUndefinedKeyword | namedTypes.TSUnknownKeyword | namedTypes.TSVoidKeyword | namedTypes.TSThisType | namedTypes.TSArrayType | namedTypes.TSLiteralType | namedTypes.TSUnionType | namedTypes.TSIntersectionType | namedTypes.TSConditionalType | namedTypes.TSInferType | namedTypes.TSTypeParameter | namedTypes.TSParenthesizedType | namedTypes.TSFunctionType | namedTypes.TSConstructorType | namedTypes.TSDeclareFunction | namedTypes.TSDeclareMethod | namedTypes.TSMappedType | namedTypes.TSTupleType | namedTypes.TSNamedTupleMember | namedTypes.TSRestType | namedTypes.TSOptionalType | namedTypes.TSIndexedAccessType | namedTypes.TSTypeOperator | namedTypes.TSIndexSignature | namedTypes.TSPropertySignature | namedTypes.TSMethodSignature | namedTypes.TSTypePredicate | namedTypes.TSCallSignatureDeclaration | namedTypes.TSConstructSignatureDeclaration | namedTypes.TSEnumMember | namedTypes.TSTypeQuery | namedTypes.TSImportType | namedTypes.TSTypeLiteral | namedTypes.TSTypeAssertion | namedTypes.TSEnumDeclaration | namedTypes.TSTypeAliasDeclaration | namedTypes.TSModuleBlock | namedTypes.TSModuleDeclaration | namedTypes.TSImportEqualsDeclaration | namedTypes.TSExternalModuleReference | namedTypes.TSExportAssignment | namedTypes.TSNamespaceExportDeclaration | namedTypes.TSInterfaceBody | namedTypes.TSInterfaceDeclaration | namedTypes.TSParameterProperty;
    export type SourceLocationKind = namedTypes.SourceLocation;
    export type NodeKind = namedTypes.File | namedTypes.Program | namedTypes.Identifier | namedTypes.BlockStatement | namedTypes.EmptyStatement | namedTypes.ExpressionStatement | namedTypes.IfStatement | namedTypes.LabeledStatement | namedTypes.BreakStatement | namedTypes.ContinueStatement | namedTypes.WithStatement | namedTypes.SwitchStatement | namedTypes.SwitchCase | namedTypes.ReturnStatement | namedTypes.ThrowStatement | namedTypes.TryStatement | namedTypes.CatchClause | namedTypes.WhileStatement | namedTypes.DoWhileStatement | namedTypes.ForStatement | namedTypes.VariableDeclaration | namedTypes.ForInStatement | namedTypes.DebuggerStatement | namedTypes.FunctionDeclaration | namedTypes.FunctionExpression | namedTypes.VariableDeclarator | namedTypes.ThisExpression | namedTypes.ArrayExpression | namedTypes.ObjectExpression | namedTypes.Property | namedTypes.Literal | namedTypes.SequenceExpression | namedTypes.UnaryExpression | namedTypes.BinaryExpression | namedTypes.AssignmentExpression | namedTypes.MemberExpression | namedTypes.UpdateExpression | namedTypes.LogicalExpression | namedTypes.ConditionalExpression | namedTypes.NewExpression | namedTypes.CallExpression | namedTypes.RestElement | namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | namedTypes.SpreadElementPattern | namedTypes.ArrowFunctionExpression | namedTypes.ForOfStatement | namedTypes.YieldExpression | namedTypes.GeneratorExpression | namedTypes.ComprehensionBlock | namedTypes.ComprehensionExpression | namedTypes.ObjectProperty | namedTypes.PropertyPattern | namedTypes.ObjectPattern | namedTypes.ArrayPattern | namedTypes.SpreadElement | namedTypes.AssignmentPattern | namedTypes.MethodDefinition | namedTypes.ClassPropertyDefinition | namedTypes.ClassProperty | namedTypes.ClassBody | namedTypes.ClassDeclaration | namedTypes.ClassExpression | namedTypes.Super | namedTypes.ImportSpecifier | namedTypes.ImportDefaultSpecifier | namedTypes.ImportNamespaceSpecifier | namedTypes.ImportDeclaration | namedTypes.ExportNamedDeclaration | namedTypes.ExportSpecifier | namedTypes.ExportDefaultDeclaration | namedTypes.ExportAllDeclaration | namedTypes.TaggedTemplateExpression | namedTypes.TemplateLiteral | namedTypes.TemplateElement | namedTypes.MetaProperty | namedTypes.AwaitExpression | namedTypes.SpreadProperty | namedTypes.SpreadPropertyPattern | namedTypes.ImportExpression | namedTypes.ChainExpression | namedTypes.OptionalCallExpression | namedTypes.OptionalMemberExpression | namedTypes.JSXAttribute | namedTypes.JSXIdentifier | namedTypes.JSXNamespacedName | namedTypes.JSXExpressionContainer | namedTypes.JSXElement | namedTypes.JSXFragment | namedTypes.JSXMemberExpression | namedTypes.JSXSpreadAttribute | namedTypes.JSXEmptyExpression | namedTypes.JSXText | namedTypes.JSXSpreadChild | namedTypes.JSXOpeningElement | namedTypes.JSXClosingElement | namedTypes.JSXOpeningFragment | namedTypes.JSXClosingFragment | namedTypes.Decorator | namedTypes.PrivateName | namedTypes.ClassPrivateProperty | namedTypes.TypeParameterDeclaration | namedTypes.TSTypeParameterDeclaration | namedTypes.TypeParameterInstantiation | namedTypes.TSTypeParameterInstantiation | namedTypes.ClassImplements | namedTypes.TSExpressionWithTypeArguments | namedTypes.AnyTypeAnnotation | namedTypes.EmptyTypeAnnotation | namedTypes.MixedTypeAnnotation | namedTypes.VoidTypeAnnotation | namedTypes.SymbolTypeAnnotation | namedTypes.NumberTypeAnnotation | namedTypes.BigIntTypeAnnotation | namedTypes.NumberLiteralTypeAnnotation | namedTypes.NumericLiteralTypeAnnotation | namedTypes.BigIntLiteralTypeAnnotation | namedTypes.StringTypeAnnotation | namedTypes.StringLiteralTypeAnnotation | namedTypes.BooleanTypeAnnotation | namedTypes.BooleanLiteralTypeAnnotation | namedTypes.NullableTypeAnnotation | namedTypes.NullLiteralTypeAnnotation | namedTypes.NullTypeAnnotation | namedTypes.ThisTypeAnnotation | namedTypes.ExistsTypeAnnotation | namedTypes.ExistentialTypeParam | namedTypes.FunctionTypeAnnotation | namedTypes.FunctionTypeParam | namedTypes.ArrayTypeAnnotation | namedTypes.ObjectTypeAnnotation | namedTypes.ObjectTypeProperty | namedTypes.ObjectTypeSpreadProperty | namedTypes.ObjectTypeIndexer | namedTypes.ObjectTypeCallProperty | namedTypes.ObjectTypeInternalSlot | namedTypes.Variance | namedTypes.QualifiedTypeIdentifier | namedTypes.GenericTypeAnnotation | namedTypes.MemberTypeAnnotation | namedTypes.UnionTypeAnnotation | namedTypes.IntersectionTypeAnnotation | namedTypes.TypeofTypeAnnotation | namedTypes.TypeParameter | namedTypes.InterfaceTypeAnnotation | namedTypes.InterfaceExtends | namedTypes.InterfaceDeclaration | namedTypes.DeclareInterface | namedTypes.TypeAlias | namedTypes.DeclareTypeAlias | namedTypes.OpaqueType | namedTypes.DeclareOpaqueType | namedTypes.TypeCastExpression | namedTypes.TupleTypeAnnotation | namedTypes.DeclareVariable | namedTypes.DeclareFunction | namedTypes.DeclareClass | namedTypes.DeclareModule | namedTypes.DeclareModuleExports | namedTypes.DeclareExportDeclaration | namedTypes.ExportBatchSpecifier | namedTypes.DeclareExportAllDeclaration | namedTypes.InferredPredicate | namedTypes.DeclaredPredicate | namedTypes.EnumDeclaration | namedTypes.ExportDeclaration | namedTypes.Noop | namedTypes.DoExpression | namedTypes.BindExpression | namedTypes.ParenthesizedExpression | namedTypes.ExportNamespaceSpecifier | namedTypes.ExportDefaultSpecifier | namedTypes.Directive | namedTypes.DirectiveLiteral | namedTypes.InterpreterDirective | namedTypes.StringLiteral | namedTypes.NumericLiteral | namedTypes.BigIntLiteral | namedTypes.NullLiteral | namedTypes.BooleanLiteral | namedTypes.RegExpLiteral | namedTypes.ObjectMethod | namedTypes.ClassMethod | namedTypes.ClassPrivateMethod | namedTypes.RestProperty | namedTypes.ForAwaitStatement | namedTypes.Import | namedTypes.TSQualifiedName | namedTypes.TSTypeReference | namedTypes.TSAsExpression | namedTypes.TSNonNullExpression | namedTypes.TSAnyKeyword | namedTypes.TSBigIntKeyword | namedTypes.TSBooleanKeyword | namedTypes.TSNeverKeyword | namedTypes.TSNullKeyword | namedTypes.TSNumberKeyword | namedTypes.TSObjectKeyword | namedTypes.TSStringKeyword | namedTypes.TSSymbolKeyword | namedTypes.TSUndefinedKeyword | namedTypes.TSUnknownKeyword | namedTypes.TSVoidKeyword | namedTypes.TSThisType | namedTypes.TSArrayType | namedTypes.TSLiteralType | namedTypes.TSUnionType | namedTypes.TSIntersectionType | namedTypes.TSConditionalType | namedTypes.TSInferType | namedTypes.TSTypeParameter | namedTypes.TSParenthesizedType | namedTypes.TSFunctionType | namedTypes.TSConstructorType | namedTypes.TSDeclareFunction | namedTypes.TSDeclareMethod | namedTypes.TSMappedType | namedTypes.TSTupleType | namedTypes.TSNamedTupleMember | namedTypes.TSRestType | namedTypes.TSOptionalType | namedTypes.TSIndexedAccessType | namedTypes.TSTypeOperator | namedTypes.TSIndexSignature | namedTypes.TSPropertySignature | namedTypes.TSMethodSignature | namedTypes.TSTypePredicate | namedTypes.TSCallSignatureDeclaration | namedTypes.TSConstructSignatureDeclaration | namedTypes.TSEnumMember | namedTypes.TSTypeQuery | namedTypes.TSImportType | namedTypes.TSTypeLiteral | namedTypes.TSTypeAssertion | namedTypes.TSEnumDeclaration | namedTypes.TSTypeAliasDeclaration | namedTypes.TSModuleBlock | namedTypes.TSModuleDeclaration | namedTypes.TSImportEqualsDeclaration | namedTypes.TSExternalModuleReference | namedTypes.TSExportAssignment | namedTypes.TSNamespaceExportDeclaration | namedTypes.TSInterfaceBody | namedTypes.TSInterfaceDeclaration | namedTypes.TSParameterProperty;
    export type CommentKind = namedTypes.Block | namedTypes.Line | namedTypes.CommentBlock | namedTypes.CommentLine;
    export type PositionKind = namedTypes.Position;
    export type FileKind = namedTypes.File;
    export type ProgramKind = namedTypes.Program;
    export type StatementKind = namedTypes.BlockStatement | namedTypes.EmptyStatement | namedTypes.ExpressionStatement | namedTypes.IfStatement | namedTypes.LabeledStatement | namedTypes.BreakStatement | namedTypes.ContinueStatement | namedTypes.WithStatement | namedTypes.SwitchStatement | namedTypes.ReturnStatement | namedTypes.ThrowStatement | namedTypes.TryStatement | namedTypes.WhileStatement | namedTypes.DoWhileStatement | namedTypes.ForStatement | namedTypes.VariableDeclaration | namedTypes.ForInStatement | namedTypes.DebuggerStatement | namedTypes.FunctionDeclaration | namedTypes.ForOfStatement | namedTypes.MethodDefinition | namedTypes.ClassPropertyDefinition | namedTypes.ClassProperty | namedTypes.ClassBody | namedTypes.ClassDeclaration | namedTypes.ImportDeclaration | namedTypes.ExportNamedDeclaration | namedTypes.ExportDefaultDeclaration | namedTypes.ExportAllDeclaration | namedTypes.ClassPrivateProperty | namedTypes.TSTypeParameterDeclaration | namedTypes.InterfaceDeclaration | namedTypes.DeclareInterface | namedTypes.TypeAlias | namedTypes.DeclareTypeAlias | namedTypes.OpaqueType | namedTypes.DeclareOpaqueType | namedTypes.DeclareVariable | namedTypes.DeclareFunction | namedTypes.DeclareClass | namedTypes.DeclareModule | namedTypes.DeclareModuleExports | namedTypes.DeclareExportDeclaration | namedTypes.DeclareExportAllDeclaration | namedTypes.EnumDeclaration | namedTypes.ExportDeclaration | namedTypes.Noop | namedTypes.ClassMethod | namedTypes.ClassPrivateMethod | namedTypes.ForAwaitStatement | namedTypes.TSDeclareFunction | namedTypes.TSDeclareMethod | namedTypes.TSIndexSignature | namedTypes.TSPropertySignature | namedTypes.TSMethodSignature | namedTypes.TSCallSignatureDeclaration | namedTypes.TSConstructSignatureDeclaration | namedTypes.TSEnumDeclaration | namedTypes.TSTypeAliasDeclaration | namedTypes.TSModuleDeclaration | namedTypes.TSImportEqualsDeclaration | namedTypes.TSExternalModuleReference | namedTypes.TSExportAssignment | namedTypes.TSNamespaceExportDeclaration | namedTypes.TSInterfaceDeclaration;
    export type FunctionKind = namedTypes.FunctionDeclaration | namedTypes.FunctionExpression | namedTypes.ArrowFunctionExpression | namedTypes.ObjectMethod | namedTypes.ClassMethod | namedTypes.ClassPrivateMethod;
    export type ExpressionKind = namedTypes.Identifier | namedTypes.FunctionExpression | namedTypes.ThisExpression | namedTypes.ArrayExpression | namedTypes.ObjectExpression | namedTypes.Literal | namedTypes.SequenceExpression | namedTypes.UnaryExpression | namedTypes.BinaryExpression | namedTypes.AssignmentExpression | namedTypes.MemberExpression | namedTypes.UpdateExpression | namedTypes.LogicalExpression | namedTypes.ConditionalExpression | namedTypes.NewExpression | namedTypes.CallExpression | namedTypes.ArrowFunctionExpression | namedTypes.YieldExpression | namedTypes.GeneratorExpression | namedTypes.ComprehensionExpression | namedTypes.ClassExpression | namedTypes.Super | namedTypes.TaggedTemplateExpression | namedTypes.TemplateLiteral | namedTypes.MetaProperty | namedTypes.AwaitExpression | namedTypes.ImportExpression | namedTypes.ChainExpression | namedTypes.OptionalCallExpression | namedTypes.OptionalMemberExpression | namedTypes.JSXIdentifier | namedTypes.JSXExpressionContainer | namedTypes.JSXElement | namedTypes.JSXFragment | namedTypes.JSXMemberExpression | namedTypes.JSXText | namedTypes.PrivateName | namedTypes.TypeCastExpression | namedTypes.DoExpression | namedTypes.BindExpression | namedTypes.ParenthesizedExpression | namedTypes.DirectiveLiteral | namedTypes.StringLiteral | namedTypes.NumericLiteral | namedTypes.BigIntLiteral | namedTypes.NullLiteral | namedTypes.BooleanLiteral | namedTypes.RegExpLiteral | namedTypes.Import | namedTypes.TSAsExpression | namedTypes.TSNonNullExpression | namedTypes.TSTypeParameter | namedTypes.TSTypeAssertion;
    export type PatternKind = namedTypes.Identifier | namedTypes.RestElement | namedTypes.SpreadElementPattern | namedTypes.PropertyPattern | namedTypes.ObjectPattern | namedTypes.ArrayPattern | namedTypes.AssignmentPattern | namedTypes.SpreadPropertyPattern | namedTypes.JSXIdentifier | namedTypes.PrivateName | namedTypes.TSAsExpression | namedTypes.TSNonNullExpression | namedTypes.TSTypeParameter | namedTypes.TSTypeAssertion | namedTypes.TSParameterProperty;
    export type IdentifierKind = namedTypes.Identifier | namedTypes.JSXIdentifier | namedTypes.TSTypeParameter;
    export type BlockStatementKind = namedTypes.BlockStatement;
    export type EmptyStatementKind = namedTypes.EmptyStatement;
    export type ExpressionStatementKind = namedTypes.ExpressionStatement;
    export type IfStatementKind = namedTypes.IfStatement;
    export type LabeledStatementKind = namedTypes.LabeledStatement;
    export type BreakStatementKind = namedTypes.BreakStatement;
    export type ContinueStatementKind = namedTypes.ContinueStatement;
    export type WithStatementKind = namedTypes.WithStatement;
    export type SwitchStatementKind = namedTypes.SwitchStatement;
    export type SwitchCaseKind = namedTypes.SwitchCase;
    export type ReturnStatementKind = namedTypes.ReturnStatement;
    export type ThrowStatementKind = namedTypes.ThrowStatement;
    export type TryStatementKind = namedTypes.TryStatement;
    export type CatchClauseKind = namedTypes.CatchClause;
    export type WhileStatementKind = namedTypes.WhileStatement;
    export type DoWhileStatementKind = namedTypes.DoWhileStatement;
    export type ForStatementKind = namedTypes.ForStatement;
    export type DeclarationKind = namedTypes.VariableDeclaration | namedTypes.FunctionDeclaration | namedTypes.MethodDefinition | namedTypes.ClassPropertyDefinition | namedTypes.ClassProperty | namedTypes.ClassBody | namedTypes.ClassDeclaration | namedTypes.ImportDeclaration | namedTypes.ExportNamedDeclaration | namedTypes.ExportDefaultDeclaration | namedTypes.ExportAllDeclaration | namedTypes.ClassPrivateProperty | namedTypes.TSTypeParameterDeclaration | namedTypes.InterfaceDeclaration | namedTypes.DeclareInterface | namedTypes.TypeAlias | namedTypes.DeclareTypeAlias | namedTypes.OpaqueType | namedTypes.DeclareOpaqueType | namedTypes.DeclareClass | namedTypes.DeclareExportDeclaration | namedTypes.DeclareExportAllDeclaration | namedTypes.EnumDeclaration | namedTypes.ExportDeclaration | namedTypes.ClassMethod | namedTypes.ClassPrivateMethod | namedTypes.TSDeclareFunction | namedTypes.TSDeclareMethod | namedTypes.TSIndexSignature | namedTypes.TSPropertySignature | namedTypes.TSMethodSignature | namedTypes.TSCallSignatureDeclaration | namedTypes.TSConstructSignatureDeclaration | namedTypes.TSEnumDeclaration | namedTypes.TSTypeAliasDeclaration | namedTypes.TSModuleDeclaration | namedTypes.TSImportEqualsDeclaration | namedTypes.TSExternalModuleReference | namedTypes.TSNamespaceExportDeclaration | namedTypes.TSInterfaceDeclaration;
    export type VariableDeclarationKind = namedTypes.VariableDeclaration;
    export type ForInStatementKind = namedTypes.ForInStatement;
    export type DebuggerStatementKind = namedTypes.DebuggerStatement;
    export type FunctionDeclarationKind = namedTypes.FunctionDeclaration;
    export type FunctionExpressionKind = namedTypes.FunctionExpression;
    export type VariableDeclaratorKind = namedTypes.VariableDeclarator;
    export type ThisExpressionKind = namedTypes.ThisExpression;
    export type ArrayExpressionKind = namedTypes.ArrayExpression;
    export type ObjectExpressionKind = namedTypes.ObjectExpression;
    export type PropertyKind = namedTypes.Property;
    export type LiteralKind = namedTypes.Literal | namedTypes.JSXText | namedTypes.StringLiteral | namedTypes.NumericLiteral | namedTypes.BigIntLiteral | namedTypes.NullLiteral | namedTypes.BooleanLiteral | namedTypes.RegExpLiteral;
    export type SequenceExpressionKind = namedTypes.SequenceExpression;
    export type UnaryExpressionKind = namedTypes.UnaryExpression;
    export type BinaryExpressionKind = namedTypes.BinaryExpression;
    export type AssignmentExpressionKind = namedTypes.AssignmentExpression;
    export type ChainElementKind = namedTypes.MemberExpression | namedTypes.CallExpression | namedTypes.OptionalCallExpression | namedTypes.OptionalMemberExpression | namedTypes.JSXMemberExpression;
    export type MemberExpressionKind = namedTypes.MemberExpression | namedTypes.OptionalMemberExpression | namedTypes.JSXMemberExpression;
    export type UpdateExpressionKind = namedTypes.UpdateExpression;
    export type LogicalExpressionKind = namedTypes.LogicalExpression;
    export type ConditionalExpressionKind = namedTypes.ConditionalExpression;
    export type NewExpressionKind = namedTypes.NewExpression;
    export type CallExpressionKind = namedTypes.CallExpression | namedTypes.OptionalCallExpression;
    export type RestElementKind = namedTypes.RestElement;
    export type TypeAnnotationKind = namedTypes.TypeAnnotation;
    export type TSTypeAnnotationKind = namedTypes.TSTypeAnnotation | namedTypes.TSTypePredicate;
    export type SpreadElementPatternKind = namedTypes.SpreadElementPattern;
    export type ArrowFunctionExpressionKind = namedTypes.ArrowFunctionExpression;
    export type ForOfStatementKind = namedTypes.ForOfStatement;
    export type YieldExpressionKind = namedTypes.YieldExpression;
    export type GeneratorExpressionKind = namedTypes.GeneratorExpression;
    export type ComprehensionBlockKind = namedTypes.ComprehensionBlock;
    export type ComprehensionExpressionKind = namedTypes.ComprehensionExpression;
    export type ObjectPropertyKind = namedTypes.ObjectProperty;
    export type PropertyPatternKind = namedTypes.PropertyPattern;
    export type ObjectPatternKind = namedTypes.ObjectPattern;
    export type ArrayPatternKind = namedTypes.ArrayPattern;
    export type SpreadElementKind = namedTypes.SpreadElement;
    export type AssignmentPatternKind = namedTypes.AssignmentPattern;
    export type MethodDefinitionKind = namedTypes.MethodDefinition;
    export type ClassPropertyDefinitionKind = namedTypes.ClassPropertyDefinition;
    export type ClassPropertyKind = namedTypes.ClassProperty | namedTypes.ClassPrivateProperty;
    export type ClassBodyKind = namedTypes.ClassBody;
    export type ClassDeclarationKind = namedTypes.ClassDeclaration;
    export type ClassExpressionKind = namedTypes.ClassExpression;
    export type SuperKind = namedTypes.Super;
    export type SpecifierKind = namedTypes.ImportSpecifier | namedTypes.ImportDefaultSpecifier | namedTypes.ImportNamespaceSpecifier | namedTypes.ExportSpecifier | namedTypes.ExportBatchSpecifier | namedTypes.ExportNamespaceSpecifier | namedTypes.ExportDefaultSpecifier;
    export type ModuleSpecifierKind = namedTypes.ImportSpecifier | namedTypes.ImportDefaultSpecifier | namedTypes.ImportNamespaceSpecifier | namedTypes.ExportSpecifier;
    export type ImportSpecifierKind = namedTypes.ImportSpecifier;
    export type ImportDefaultSpecifierKind = namedTypes.ImportDefaultSpecifier;
    export type ImportNamespaceSpecifierKind = namedTypes.ImportNamespaceSpecifier;
    export type ImportDeclarationKind = namedTypes.ImportDeclaration;
    export type ExportNamedDeclarationKind = namedTypes.ExportNamedDeclaration;
    export type ExportSpecifierKind = namedTypes.ExportSpecifier;
    export type ExportDefaultDeclarationKind = namedTypes.ExportDefaultDeclaration;
    export type ExportAllDeclarationKind = namedTypes.ExportAllDeclaration;
    export type TaggedTemplateExpressionKind = namedTypes.TaggedTemplateExpression;
    export type TemplateLiteralKind = namedTypes.TemplateLiteral;
    export type TemplateElementKind = namedTypes.TemplateElement;
    export type MetaPropertyKind = namedTypes.MetaProperty;
    export type AwaitExpressionKind = namedTypes.AwaitExpression;
    export type SpreadPropertyKind = namedTypes.SpreadProperty;
    export type SpreadPropertyPatternKind = namedTypes.SpreadPropertyPattern;
    export type ImportExpressionKind = namedTypes.ImportExpression;
    export type ChainExpressionKind = namedTypes.ChainExpression;
    export type OptionalCallExpressionKind = namedTypes.OptionalCallExpression;
    export type OptionalMemberExpressionKind = namedTypes.OptionalMemberExpression;
    export type JSXAttributeKind = namedTypes.JSXAttribute;
    export type JSXIdentifierKind = namedTypes.JSXIdentifier;
    export type JSXNamespacedNameKind = namedTypes.JSXNamespacedName;
    export type JSXExpressionContainerKind = namedTypes.JSXExpressionContainer;
    export type JSXElementKind = namedTypes.JSXElement;
    export type JSXFragmentKind = namedTypes.JSXFragment;
    export type JSXMemberExpressionKind = namedTypes.JSXMemberExpression;
    export type JSXSpreadAttributeKind = namedTypes.JSXSpreadAttribute;
    export type JSXEmptyExpressionKind = namedTypes.JSXEmptyExpression;
    export type JSXTextKind = namedTypes.JSXText;
    export type JSXSpreadChildKind = namedTypes.JSXSpreadChild;
    export type JSXOpeningElementKind = namedTypes.JSXOpeningElement;
    export type JSXClosingElementKind = namedTypes.JSXClosingElement;
    export type JSXOpeningFragmentKind = namedTypes.JSXOpeningFragment;
    export type JSXClosingFragmentKind = namedTypes.JSXClosingFragment;
    export type DecoratorKind = namedTypes.Decorator;
    export type PrivateNameKind = namedTypes.PrivateName;
    export type ClassPrivatePropertyKind = namedTypes.ClassPrivateProperty;
    export type TypeParameterDeclarationKind = namedTypes.TypeParameterDeclaration;
    export type TSTypeParameterDeclarationKind = namedTypes.TSTypeParameterDeclaration;
    export type TypeParameterInstantiationKind = namedTypes.TypeParameterInstantiation;
    export type TSTypeParameterInstantiationKind = namedTypes.TSTypeParameterInstantiation;
    export type ClassImplementsKind = namedTypes.ClassImplements;
    export type TSTypeKind = namedTypes.TSExpressionWithTypeArguments | namedTypes.TSTypeReference | namedTypes.TSAnyKeyword | namedTypes.TSBigIntKeyword | namedTypes.TSBooleanKeyword | namedTypes.TSNeverKeyword | namedTypes.TSNullKeyword | namedTypes.TSNumberKeyword | namedTypes.TSObjectKeyword | namedTypes.TSStringKeyword | namedTypes.TSSymbolKeyword | namedTypes.TSUndefinedKeyword | namedTypes.TSUnknownKeyword | namedTypes.TSVoidKeyword | namedTypes.TSThisType | namedTypes.TSArrayType | namedTypes.TSLiteralType | namedTypes.TSUnionType | namedTypes.TSIntersectionType | namedTypes.TSConditionalType | namedTypes.TSInferType | namedTypes.TSParenthesizedType | namedTypes.TSFunctionType | namedTypes.TSConstructorType | namedTypes.TSMappedType | namedTypes.TSTupleType | namedTypes.TSNamedTupleMember | namedTypes.TSRestType | namedTypes.TSOptionalType | namedTypes.TSIndexedAccessType | namedTypes.TSTypeOperator | namedTypes.TSTypePredicate | namedTypes.TSTypeQuery | namedTypes.TSImportType | namedTypes.TSTypeLiteral;
    export type TSHasOptionalTypeParameterInstantiationKind = namedTypes.TSExpressionWithTypeArguments | namedTypes.TSTypeReference | namedTypes.TSImportType;
    export type TSExpressionWithTypeArgumentsKind = namedTypes.TSExpressionWithTypeArguments;
    export type FlowKind = namedTypes.AnyTypeAnnotation | namedTypes.EmptyTypeAnnotation | namedTypes.MixedTypeAnnotation | namedTypes.VoidTypeAnnotation | namedTypes.SymbolTypeAnnotation | namedTypes.NumberTypeAnnotation | namedTypes.BigIntTypeAnnotation | namedTypes.NumberLiteralTypeAnnotation | namedTypes.NumericLiteralTypeAnnotation | namedTypes.BigIntLiteralTypeAnnotation | namedTypes.StringTypeAnnotation | namedTypes.StringLiteralTypeAnnotation | namedTypes.BooleanTypeAnnotation | namedTypes.BooleanLiteralTypeAnnotation | namedTypes.NullableTypeAnnotation | namedTypes.NullLiteralTypeAnnotation | namedTypes.NullTypeAnnotation | namedTypes.ThisTypeAnnotation | namedTypes.ExistsTypeAnnotation | namedTypes.ExistentialTypeParam | namedTypes.FunctionTypeAnnotation | namedTypes.ArrayTypeAnnotation | namedTypes.ObjectTypeAnnotation | namedTypes.GenericTypeAnnotation | namedTypes.MemberTypeAnnotation | namedTypes.UnionTypeAnnotation | namedTypes.IntersectionTypeAnnotation | namedTypes.TypeofTypeAnnotation | namedTypes.TypeParameter | namedTypes.InterfaceTypeAnnotation | namedTypes.TupleTypeAnnotation | namedTypes.InferredPredicate | namedTypes.DeclaredPredicate;
    export type FlowTypeKind = namedTypes.AnyTypeAnnotation | namedTypes.EmptyTypeAnnotation | namedTypes.MixedTypeAnnotation | namedTypes.VoidTypeAnnotation | namedTypes.SymbolTypeAnnotation | namedTypes.NumberTypeAnnotation | namedTypes.BigIntTypeAnnotation | namedTypes.NumberLiteralTypeAnnotation | namedTypes.NumericLiteralTypeAnnotation | namedTypes.BigIntLiteralTypeAnnotation | namedTypes.StringTypeAnnotation | namedTypes.StringLiteralTypeAnnotation | namedTypes.BooleanTypeAnnotation | namedTypes.BooleanLiteralTypeAnnotation | namedTypes.NullableTypeAnnotation | namedTypes.NullLiteralTypeAnnotation | namedTypes.NullTypeAnnotation | namedTypes.ThisTypeAnnotation | namedTypes.ExistsTypeAnnotation | namedTypes.ExistentialTypeParam | namedTypes.FunctionTypeAnnotation | namedTypes.ArrayTypeAnnotation | namedTypes.ObjectTypeAnnotation | namedTypes.GenericTypeAnnotation | namedTypes.MemberTypeAnnotation | namedTypes.UnionTypeAnnotation | namedTypes.IntersectionTypeAnnotation | namedTypes.TypeofTypeAnnotation | namedTypes.TypeParameter | namedTypes.InterfaceTypeAnnotation | namedTypes.TupleTypeAnnotation;
    export type AnyTypeAnnotationKind = namedTypes.AnyTypeAnnotation;
    export type EmptyTypeAnnotationKind = namedTypes.EmptyTypeAnnotation;
    export type MixedTypeAnnotationKind = namedTypes.MixedTypeAnnotation;
    export type VoidTypeAnnotationKind = namedTypes.VoidTypeAnnotation;
    export type SymbolTypeAnnotationKind = namedTypes.SymbolTypeAnnotation;
    export type NumberTypeAnnotationKind = namedTypes.NumberTypeAnnotation;
    export type BigIntTypeAnnotationKind = namedTypes.BigIntTypeAnnotation;
    export type NumberLiteralTypeAnnotationKind = namedTypes.NumberLiteralTypeAnnotation;
    export type NumericLiteralTypeAnnotationKind = namedTypes.NumericLiteralTypeAnnotation;
    export type BigIntLiteralTypeAnnotationKind = namedTypes.BigIntLiteralTypeAnnotation;
    export type StringTypeAnnotationKind = namedTypes.StringTypeAnnotation;
    export type StringLiteralTypeAnnotationKind = namedTypes.StringLiteralTypeAnnotation;
    export type BooleanTypeAnnotationKind = namedTypes.BooleanTypeAnnotation;
    export type BooleanLiteralTypeAnnotationKind = namedTypes.BooleanLiteralTypeAnnotation;
    export type NullableTypeAnnotationKind = namedTypes.NullableTypeAnnotation;
    export type NullLiteralTypeAnnotationKind = namedTypes.NullLiteralTypeAnnotation;
    export type NullTypeAnnotationKind = namedTypes.NullTypeAnnotation;
    export type ThisTypeAnnotationKind = namedTypes.ThisTypeAnnotation;
    export type ExistsTypeAnnotationKind = namedTypes.ExistsTypeAnnotation;
    export type ExistentialTypeParamKind = namedTypes.ExistentialTypeParam;
    export type FunctionTypeAnnotationKind = namedTypes.FunctionTypeAnnotation;
    export type FunctionTypeParamKind = namedTypes.FunctionTypeParam;
    export type ArrayTypeAnnotationKind = namedTypes.ArrayTypeAnnotation;
    export type ObjectTypeAnnotationKind = namedTypes.ObjectTypeAnnotation;
    export type ObjectTypePropertyKind = namedTypes.ObjectTypeProperty;
    export type ObjectTypeSpreadPropertyKind = namedTypes.ObjectTypeSpreadProperty;
    export type ObjectTypeIndexerKind = namedTypes.ObjectTypeIndexer;
    export type ObjectTypeCallPropertyKind = namedTypes.ObjectTypeCallProperty;
    export type ObjectTypeInternalSlotKind = namedTypes.ObjectTypeInternalSlot;
    export type VarianceKind = namedTypes.Variance;
    export type QualifiedTypeIdentifierKind = namedTypes.QualifiedTypeIdentifier;
    export type GenericTypeAnnotationKind = namedTypes.GenericTypeAnnotation;
    export type MemberTypeAnnotationKind = namedTypes.MemberTypeAnnotation;
    export type UnionTypeAnnotationKind = namedTypes.UnionTypeAnnotation;
    export type IntersectionTypeAnnotationKind = namedTypes.IntersectionTypeAnnotation;
    export type TypeofTypeAnnotationKind = namedTypes.TypeofTypeAnnotation;
    export type TypeParameterKind = namedTypes.TypeParameter;
    export type InterfaceTypeAnnotationKind = namedTypes.InterfaceTypeAnnotation;
    export type InterfaceExtendsKind = namedTypes.InterfaceExtends;
    export type InterfaceDeclarationKind = namedTypes.InterfaceDeclaration | namedTypes.DeclareInterface | namedTypes.DeclareClass;
    export type DeclareInterfaceKind = namedTypes.DeclareInterface;
    export type TypeAliasKind = namedTypes.TypeAlias | namedTypes.DeclareTypeAlias;
    export type DeclareTypeAliasKind = namedTypes.DeclareTypeAlias;
    export type OpaqueTypeKind = namedTypes.OpaqueType | namedTypes.DeclareOpaqueType;
    export type DeclareOpaqueTypeKind = namedTypes.DeclareOpaqueType;
    export type TypeCastExpressionKind = namedTypes.TypeCastExpression;
    export type TupleTypeAnnotationKind = namedTypes.TupleTypeAnnotation;
    export type DeclareVariableKind = namedTypes.DeclareVariable;
    export type DeclareFunctionKind = namedTypes.DeclareFunction;
    export type FlowPredicateKind = namedTypes.InferredPredicate | namedTypes.DeclaredPredicate;
    export type DeclareClassKind = namedTypes.DeclareClass;
    export type DeclareModuleKind = namedTypes.DeclareModule;
    export type DeclareModuleExportsKind = namedTypes.DeclareModuleExports;
    export type DeclareExportDeclarationKind = namedTypes.DeclareExportDeclaration;
    export type ExportBatchSpecifierKind = namedTypes.ExportBatchSpecifier;
    export type DeclareExportAllDeclarationKind = namedTypes.DeclareExportAllDeclaration;
    export type InferredPredicateKind = namedTypes.InferredPredicate;
    export type DeclaredPredicateKind = namedTypes.DeclaredPredicate;
    export type EnumDeclarationKind = namedTypes.EnumDeclaration;
    export type EnumBooleanBodyKind = namedTypes.EnumBooleanBody;
    export type EnumNumberBodyKind = namedTypes.EnumNumberBody;
    export type EnumStringBodyKind = namedTypes.EnumStringBody;
    export type EnumSymbolBodyKind = namedTypes.EnumSymbolBody;
    export type EnumBooleanMemberKind = namedTypes.EnumBooleanMember;
    export type EnumNumberMemberKind = namedTypes.EnumNumberMember;
    export type EnumStringMemberKind = namedTypes.EnumStringMember;
    export type EnumDefaultedMemberKind = namedTypes.EnumDefaultedMember;
    export type ExportDeclarationKind = namedTypes.ExportDeclaration;
    export type BlockKind = namedTypes.Block;
    export type LineKind = namedTypes.Line;
    export type NoopKind = namedTypes.Noop;
    export type DoExpressionKind = namedTypes.DoExpression;
    export type BindExpressionKind = namedTypes.BindExpression;
    export type ParenthesizedExpressionKind = namedTypes.ParenthesizedExpression;
    export type ExportNamespaceSpecifierKind = namedTypes.ExportNamespaceSpecifier;
    export type ExportDefaultSpecifierKind = namedTypes.ExportDefaultSpecifier;
    export type CommentBlockKind = namedTypes.CommentBlock;
    export type CommentLineKind = namedTypes.CommentLine;
    export type DirectiveKind = namedTypes.Directive;
    export type DirectiveLiteralKind = namedTypes.DirectiveLiteral;
    export type InterpreterDirectiveKind = namedTypes.InterpreterDirective;
    export type StringLiteralKind = namedTypes.StringLiteral;
    export type NumericLiteralKind = namedTypes.NumericLiteral;
    export type BigIntLiteralKind = namedTypes.BigIntLiteral;
    export type NullLiteralKind = namedTypes.NullLiteral;
    export type BooleanLiteralKind = namedTypes.BooleanLiteral;
    export type RegExpLiteralKind = namedTypes.RegExpLiteral;
    export type ObjectMethodKind = namedTypes.ObjectMethod;
    export type ClassMethodKind = namedTypes.ClassMethod;
    export type ClassPrivateMethodKind = namedTypes.ClassPrivateMethod;
    export type RestPropertyKind = namedTypes.RestProperty;
    export type ForAwaitStatementKind = namedTypes.ForAwaitStatement;
    export type ImportKind = namedTypes.Import;
    export type TSQualifiedNameKind = namedTypes.TSQualifiedName;
    export type TSTypeReferenceKind = namedTypes.TSTypeReference;
    export type TSHasOptionalTypeParametersKind = namedTypes.TSFunctionType | namedTypes.TSConstructorType | namedTypes.TSDeclareFunction | namedTypes.TSDeclareMethod | namedTypes.TSMethodSignature | namedTypes.TSCallSignatureDeclaration | namedTypes.TSConstructSignatureDeclaration | namedTypes.TSTypeAliasDeclaration | namedTypes.TSInterfaceDeclaration;
    export type TSHasOptionalTypeAnnotationKind = namedTypes.TSFunctionType | namedTypes.TSConstructorType | namedTypes.TSIndexSignature | namedTypes.TSPropertySignature | namedTypes.TSMethodSignature | namedTypes.TSCallSignatureDeclaration | namedTypes.TSConstructSignatureDeclaration;
    export type TSAsExpressionKind = namedTypes.TSAsExpression;
    export type TSNonNullExpressionKind = namedTypes.TSNonNullExpression;
    export type TSAnyKeywordKind = namedTypes.TSAnyKeyword;
    export type TSBigIntKeywordKind = namedTypes.TSBigIntKeyword;
    export type TSBooleanKeywordKind = namedTypes.TSBooleanKeyword;
    export type TSNeverKeywordKind = namedTypes.TSNeverKeyword;
    export type TSNullKeywordKind = namedTypes.TSNullKeyword;
    export type TSNumberKeywordKind = namedTypes.TSNumberKeyword;
    export type TSObjectKeywordKind = namedTypes.TSObjectKeyword;
    export type TSStringKeywordKind = namedTypes.TSStringKeyword;
    export type TSSymbolKeywordKind = namedTypes.TSSymbolKeyword;
    export type TSUndefinedKeywordKind = namedTypes.TSUndefinedKeyword;
    export type TSUnknownKeywordKind = namedTypes.TSUnknownKeyword;
    export type TSVoidKeywordKind = namedTypes.TSVoidKeyword;
    export type TSThisTypeKind = namedTypes.TSThisType;
    export type TSArrayTypeKind = namedTypes.TSArrayType;
    export type TSLiteralTypeKind = namedTypes.TSLiteralType;
    export type TSUnionTypeKind = namedTypes.TSUnionType;
    export type TSIntersectionTypeKind = namedTypes.TSIntersectionType;
    export type TSConditionalTypeKind = namedTypes.TSConditionalType;
    export type TSInferTypeKind = namedTypes.TSInferType;
    export type TSTypeParameterKind = namedTypes.TSTypeParameter;
    export type TSParenthesizedTypeKind = namedTypes.TSParenthesizedType;
    export type TSFunctionTypeKind = namedTypes.TSFunctionType;
    export type TSConstructorTypeKind = namedTypes.TSConstructorType;
    export type TSDeclareFunctionKind = namedTypes.TSDeclareFunction;
    export type TSDeclareMethodKind = namedTypes.TSDeclareMethod;
    export type TSMappedTypeKind = namedTypes.TSMappedType;
    export type TSTupleTypeKind = namedTypes.TSTupleType;
    export type TSNamedTupleMemberKind = namedTypes.TSNamedTupleMember;
    export type TSRestTypeKind = namedTypes.TSRestType;
    export type TSOptionalTypeKind = namedTypes.TSOptionalType;
    export type TSIndexedAccessTypeKind = namedTypes.TSIndexedAccessType;
    export type TSTypeOperatorKind = namedTypes.TSTypeOperator;
    export type TSIndexSignatureKind = namedTypes.TSIndexSignature;
    export type TSPropertySignatureKind = namedTypes.TSPropertySignature;
    export type TSMethodSignatureKind = namedTypes.TSMethodSignature;
    export type TSTypePredicateKind = namedTypes.TSTypePredicate;
    export type TSCallSignatureDeclarationKind = namedTypes.TSCallSignatureDeclaration;
    export type TSConstructSignatureDeclarationKind = namedTypes.TSConstructSignatureDeclaration;
    export type TSEnumMemberKind = namedTypes.TSEnumMember;
    export type TSTypeQueryKind = namedTypes.TSTypeQuery;
    export type TSImportTypeKind = namedTypes.TSImportType;
    export type TSTypeLiteralKind = namedTypes.TSTypeLiteral;
    export type TSTypeAssertionKind = namedTypes.TSTypeAssertion;
    export type TSEnumDeclarationKind = namedTypes.TSEnumDeclaration;
    export type TSTypeAliasDeclarationKind = namedTypes.TSTypeAliasDeclaration;
    export type TSModuleBlockKind = namedTypes.TSModuleBlock;
    export type TSModuleDeclarationKind = namedTypes.TSModuleDeclaration;
    export type TSImportEqualsDeclarationKind = namedTypes.TSImportEqualsDeclaration;
    export type TSExternalModuleReferenceKind = namedTypes.TSExternalModuleReference;
    export type TSExportAssignmentKind = namedTypes.TSExportAssignment;
    export type TSNamespaceExportDeclarationKind = namedTypes.TSNamespaceExportDeclaration;
    export type TSInterfaceBodyKind = namedTypes.TSInterfaceBody;
    export type TSInterfaceDeclarationKind = namedTypes.TSInterfaceDeclaration;
    export type TSParameterPropertyKind = namedTypes.TSParameterProperty;
}

declare module 'ast-types/lib/path-visitor' {
    import { Fork, Omit } from "ast-types/types";
    import { ASTNode } from "ast-types/lib/types";
    import { NodePath } from "ast-types/lib/node-path";
    export interface PathVisitor {
        _reusableContextStack: any;
        _methodNameTable: any;
        _shouldVisitComments: any;
        Context: any;
        _visiting: any;
        _changeReported: any;
        _abortRequested: boolean;
        visit(...args: any[]): any;
        reset(...args: any[]): any;
        visitWithoutReset(path: any): any;
        AbortRequest: any;
        abort(): void;
        visitor: any;
        acquireContext(path: any): any;
        releaseContext(context: any): void;
        reportChanged(): void;
        wasChangeReported(): any;
    }
    export interface PathVisitorStatics {
        fromMethodsObject(methods?: any): Visitor;
        visit<M = {}>(node: ASTNode, methods?: import("../gen/visitor").Visitor<M>): any;
    }
    export interface PathVisitorConstructor extends PathVisitorStatics {
        new (): PathVisitor;
    }
    export interface Visitor extends PathVisitor {
    }
    export interface VisitorConstructor extends PathVisitorStatics {
        new (): Visitor;
    }
    export interface VisitorMethods {
        [visitorMethod: string]: (path: NodePath) => any;
    }
    export interface SharedContextMethods {
        currentPath: any;
        needToCallTraverse: boolean;
        Context: any;
        visitor: any;
        reset(path: any, ...args: any[]): any;
        invokeVisitorMethod(methodName: string): any;
        traverse(path: any, newVisitor?: VisitorMethods): any;
        visit(path: any, newVisitor?: VisitorMethods): any;
        reportChanged(): void;
        abort(): void;
    }
    export interface Context extends Omit<PathVisitor, "visit" | "reset">, SharedContextMethods {
    }
    export default function pathVisitorPlugin(fork: Fork): PathVisitorConstructor;
}

